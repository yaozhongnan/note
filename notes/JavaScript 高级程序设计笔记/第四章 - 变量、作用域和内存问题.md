# 第四章 - 变量、作用域和内存问题

JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。

由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。

尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性。

但 JavaScript 变量实际的复杂程度还远不止如此。



## 基本类型和引用类型

ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。

基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 

在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。

基本数据类型（五种）是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。

与其他语言不同，JavaScript 不允许直接访问内存中的位置。

也就是说不能直接操作对象的内存空间。

在操作对象时，实际上是在操作对象的引用而不是实际的对象。

为此，引用类型的值是按引用（不严密，见 68 页注解）访问的。 

在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript 放弃了这一传统。



## 传递参数

**结论：ECMAScript 中所有函数的参数都是按值传递的。**

有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数）。

在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

下面证明一下为什么所有函数的参数都是按值传递的，看第一个例子：

```js
function addTen(num) { 
    num += 10; 
    return num; 
} 
var count = 20; 
var result = addTen(count); 
alert(count);    //20，没有变化 
alert(result);   //30
```

```js
function setName(obj) { 
    obj.name = "Nicholas"; 
} 
 
var person = new Object(); 
setName(person); 
alert(person.name);    //"Nicholas" 

/*

*/
```

