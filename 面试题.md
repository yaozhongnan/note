# 面试题

## HTML 部分

### HTML 语义化

见名知意，根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 

优点：

+ 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
+ 有利于 SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
+ 遵循 W3C 标准，可以减少差异化。 

### b 标签和 strong 标签的区别

- 两者虽然在网页中显示效果一样，但实际目的不同。
- b 这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；
- strong 这个标签意思是加强，表示该文本比较重要，提醒读者／终端注意。

## CSS 部分

### 任意元素垂直水平居中

基础结构

```css
#app {
    height: 500px;
    border: 10px solid #000;
}
.box {
    width: 200px;
    height: 200px;
    background-color: red;
}
```

```html
<div id='app'>
    <div class='box'></div>
</div>
```

方式一：兼容性好。缺点：必须知道元素的宽高 

```css
#app {
    position: relative;
}
.box {
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -100px;
    margin-top: -100px;
}
```

方式二：使用的是 css3 里的样式。缺点：兼容性不好，只支持IE9+的浏览器 

```css
#app {
    position: relative;
}
.box {
    position: absolute;
    left: 50%;
    top: 50%;
    transform:translate(-50%,-50%);
}
```

方式三：兼容性较好。缺点：不支持 IE7 以下的浏览器 

```css
#app {
    position: relative;
}
.box {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
}
```

方式四：flex

```css
#app {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

方式五：flex 结合 margin

```css
#app {
    display: flex;
}
.box {
    margin: auto;
}
```

方式六：css3 中的 display: box;

```css
#app {
    display: -webkit-box;
    -webkit-box-pack: center;
    -webkit-box-align: center;
}
```

方式七：table 布局

```css
#app {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}

.box {
    display: inline-block;
}
```

### 移动端 0.5px 实现

```css
.border{
  width: 100%;
  height:1px ;
}
/* 当像素比为 2 时，高度缩小一倍 */
@media only screen and (-webkit-device-pixel-ratio:2 ) {
  .border{
    transform: scaleY(.5);
  }
}
/* 当像素比为 3 时，高度缩小至三分之一 */
@media only screen and (-webkit-device-pixel-ratio:3 ) {
  .border{
    transform: scaleY(.333333333333333333);
}
```

### 清除浮动的方法

```css
/*清除浮动代码*/
.clearfloat::after{
    display:block;
    clear:both;
    content:"";
    visibility:hidden;
    height:0
}
.clearfloat{
    zoom:1	/* zoom(IE专有属性)可解决ie6,ie7浮动问题 */
}
```

+ 在结尾处添加空 div 标签 clear:both
+ 父级 div 定义 height 
+ 父级 div 定义 overflow:hidden;
+ 结尾处加 br 标签clear:both 

## JavaScript 部分

### Object.keys() 和 for in 的区别

+ Object.keys（obj）返回的是对象本身的属性和方法的键组成的数组
+ for in 遍历的是对象本身及其原型上的属性
### 伪数组转真数组

方式一：**Array.prototype.slice.call()**  

方式二：ES6 中 **Array.from()**  

方式三：ES6 中 **var args = [...arguments]; **

注意：ES6 的方法需要被转换的数据部署了 Iterator 接口 

### typeof 和 instanceof 的区别

typeof：检测基本数据类型和检测是否是函数很有用。但检测引用类型的值时用处不大。

instanceof： 可以检测一个对象是什么类型的对象，可以检测一个变量是否某个对象的实例。

+ alert(person instanceof Object); // 变量 person 是 Object 吗？    
+ alert(colors instanceof Array); // 变量 colors 是 Array 吗？    
+ alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？

### 箭头函数和普通函数的区别

+ 箭头函数没有绑定this指针，普通函数的this指向调用函数的对象（匿名函数的this都指向全局window对象）; 
+ 箭头函数没有构造器 

### 如何深浅拷贝一个数组

浅复制：直接使用等号赋值，例：var arr2 = arr1

深复制：

+ 使用 slice 方法截取数组，从 0 下标开始截取至末尾
+ 使用 map 方法
+ 使用 concat 方法
+ 使用 for in
+ 先将数组转字符串，在转数组

### 数组去重

+ 遍历该数组，利用 indexOf 方法查找是否存在，不存在则添加到一个新数组内
+ 使用空对象，将数组元素作为对象key值，出现次数作为value值，循环数组 
+ 普通的for循环，循环之前排序，会高效一点点 
+ 使用ES6的Set类型，[...new Set([1,2,3,2,3,1,4,5])];          //[1,2,3,4,5]; 

### 作用域，执行上下文栈，变量对象

作用域：

+ 作用域是指程序源代码中定义变量的区域。 
+ 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 
+ JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 
+ 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 
+ 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 

可执行代码：

+ 这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 
+ 其实很简单，就三种，全局代码、函数代码、eval代码。 
+ 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(execution context)"。 

执行上下文栈（管理执行上下文）：

+ 我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 

+ JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 
+ 每个执行上下文，都有三个重要属性：变量对象(Variable object，VO)，作用域链(Scope chain)，this

变量对象：

+ 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 

执行上下文的执行过程：

+ 进入执行上下文，此时的变量对象包括：
  + 函数的所有形参 (如果是函数上下文) 
  + 函数声明 
  + 变量声明 
+ 代码执行
  + 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 

### 跨域

为什么会跨域？

​	因为浏览器的同源策略，它是一个安全机制。

解决方法：

+ JSONP，但 JSONP 只能发送 get 请求，因为本质上 script 加载资源就是 get
+ 服务端设置响应头，Access-Control-Allow-Origin 等参数
+ 代理，配置 Nginx

### 性能优化方案

+ 减少 HTTP 请求，例如使用精灵图，图片懒加载。
+ 尽量少操作 DOM
+ 资源压缩与合并 
+ 浏览器缓存
+ 使用 CDN
+ 使用事件代理
+ 少用全局变量
+ 路由懒加载

### 深浅拷贝

#### 浅拷贝

```js
function simpleCopy(obj) {
    var o = {}
    Object.keys(obj).forEach(item => {
        o[item] = obj[item]
    })
    return o
}
```

#### 深拷贝

```js
function deepCopy(current, target) {
    for (var key in current) {
        // 存当前 key 的 value 值
        var value = current[key]
        // 如果这个值是数组类型
        if (value instanceof Array) {
            // 让目标对象的当前 Key 为一个空数组
            target[key] = []
            // 递归进行拷贝
            arguments.callee(value, target[key])
        } else if (value instanceof Object) {
            // 让目标对象的当前 key 为一个空对象
            target[key] = {}
            // 递归进行拷贝
            arguments.callee(value, target[key])
        } else {
            target[key] = value
        }
    }
}
```

### 模拟实现

#### new 的模拟实现

参考地址：https://github.com/mqyqingfeng/Blog/issues/13

new 的时候发生了什么

+ 创建一个新对象 
+ 将新对象的``__proto__``属性设置为构造函数的``constructor``的``prototype``
+ 使用新对象调用 apply 函数，函数中的 this 被指向新实例对象 
+ 将初始化完毕的新对象地址返回

```js
// Otaku 御宅族，简称宅
function Otaku(name, age) {
    this.name = name;
    this.age = age;

    this.habit = 'Games';
}

// 因为缺乏锻炼的缘故，身体强度让人担忧
Otaku.prototype.strength = 60;

Otaku.prototype.sayYourName = function () {
    console.log('I am ' + this.name);
}

function objectFactory() {
    // 创建一个新对象
    var obj = new Object(),
	// 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
        Constructor = [].shift.call(arguments);
	// 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性
    obj.__proto__ = Constructor.prototype;
	// 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性，用 ret 接受函数调用的一个返回值
    var ret = Constructor.apply(obj, arguments);
	// 对返回值进行判断是否为对象
    return typeof ret === 'object' ? ret : obj;

}

var instance = objectFactory(Otaku, 'yzn', 23)
```

#### call 的模拟实现

`call()` 方法**调用**一个函数, 其具有一个指定的`this`值和分别地提供的参数(**参数的列表**)。

ES3 实现方式

```js
Function.prototype.call = function (context) {
    context = context || window;
    // 该 this 表示的是 call 函数的调用者，也就是那个想被调用的函数，例：fn.call()，this 就是这个 fn
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    // 此时的 args = ["arguments[1]", "arguments[2]", ...]
	
    // 这里的 args 会调用 toString() 方法
    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
```

ES6 实现方式

```js
Function.prototype.call = function(context, ...args) {
     context = context || window;
     let fn = Symbol()
     context[fn] = this;
     var result =  context[fn](...args)
     Reflect.deleteProperty(context, fn)
     return result;
 }
```

#### apply 的模拟实现

**apply()** 方法调用一个具有给定`this`值的函数，以及作为一个数组（或[类似数组对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects)）提供的参数。 

```js
Function.prototype.apply = function (context, arr) {
    context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
```

#### bind 的模拟实现

`bind()`方法创建一个新的函数，在调用时设置`this`关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。 

参考地址：https://github.com/mqyqingfeng/Blog/issues/12

```js
Function.prototype.bind2 = function (context) {
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }
    
    var self = this;
    // 取出 bind 时传入的参数并转换为一个数组，例：fn.bind(this, 1, 2)，args = [1, 2]
    var args = Array.prototype.slice.call(arguments, 1);
	// 利用一个空函数进行中转
    var fNOP = function () {};
	
    var fBound = function () {
        // 取出 bind 返回的函数调用时传入的参数，例，fBound(3, 4)，bindArgs = [3, 4]
        var bindArgs = Array.prototype.slice.call(arguments);
        
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }
	
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

## Vue 部分

### Vue 组件通信相关方法

方式一：vue 父子组件通信可以用 Vue.$emit 自定义事件来解决。 

```html
<!-- 父组件 -->
<single-address @edit-address="editAddress"></single-address>
```

```js
// 子组件
methods: {
 editAddress () {
  this.$emit('edit-address', false)
 }
}
```

方式二：利用 props 通信
```html
<!-- 父组件 -->
<one-address :addressitems="addressitems"></one-address>
```

```js
// 子组件
<div>{{ addressitems.partment }}{{ addressitems.address }}</div>

export default {
  props: {
    addressitems: Object
  }
}
```

方式三：非父子组件通信

```js
// 新建一个 bus.js 文件，在需要通信的组件都引入该 bus.js 文件
import Vue from 'vue'
export default new Vue()
```

```js
// 传递数据的组件中
Bus.$emit('on', 'hello')
```

```js
// 接收数据的组件中
Bus.$on('on', (msg) => {
    this.message = msg	// hello
})
```

方式四：使用 vm 实例属性，``$attr``  和  ``$listeners``

方式五：使用 provide 和 inject，主要为高阶插件/组件库提供用例。 

方式六：`$parent` 和 `$children` 

方式七：Vuex

### Vue 生命周期都做了什么事情

+ 首先创建了一个空的 Vue 实例对象，然后初始化一些生命周期函数和默认事件
+ 在 beforeCreate 执行的时候 data 和 methods 中的数据还没有初始化完成
+ 在 beforeCreate 执行完成之后，data 和 methods 中的数据都已经被初始化完成了
+ 这时 created 钩子中可以访问到 data 和 methods 中的数据
+ 在 created 和 beforeMount 之间 Vue 开始编译好模板，放在内存中
+ 接着 beforeMount 钩子执行，但此时内存中的模板还未挂在到页面中
+ 在 beforeMount 钩子执行完后，才把内存中的模板挂载到页面中去
+ 然后 mounted 钩子执行，此时 Vue 实例初始化完毕，并在该阶段可以操作 DOM 了
+ 在 mounted 和 beforeDestory 之间是 beforeUpdate 和 update 钩子
+ 接着 beforeDestory 钩子执行，此时 Vue 实例准备销毁，但仍然可以访问 data 和 methods 等数据
+ 当执行 destoryed 钩子时，所有的指令方法等都不可用了，Vue 实例被销毁。

### new Vue 发生了什么

Vue 初始化只要就是干了这几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等。

初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。

## 浏览器部分

### 防止浏览器缓存的方法

方式一：meta方法 有时候谷歌等浏览器不支持 

```html
<META HTTP-EQUIV="pragma"CONTENT="no-cache">
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<META HTTP-EQUIV="expires" CONTENT="0">
```

方式二：请求头添加 If-Modified-Since 和 Cache-Control 

```js
$.ajax({
    url: 'www.xxxxxx.com',
    dataType: 'json',
    beforeSend: function (xmlHttp) {
        xmlHttp.setRequestHeader("If-Modified-Since", "0");
        xmlHttp.setRequestHeader("Cache-Control", "no-cache");
    },
});
```

方式三：在 url 后加上随机数或时间戳

方式四：服务端设置 header("Cache-Control: no-cache, must-revalidate"); 

## HTTP 部分

### HTTP 和 HTTPS 有何区别？如何灵活使用

http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 

https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份 

### GET 请求和 POST 请求的区别

+ get 请求可以被缓存，post 不可以
+ 编码类型不同，post 请求可以为 form-data
+ get 请求有长度限制，post 没有
+ get 请求的安全性较差，因为所发送的参数是 url 的一部分
+ get 请求的数据所有人都可见，post 请求的数据不会显示在 url 中
+ get 请求可以收藏为书签，post 不可以

## Axios

Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 

### Axios 的特点

+ 从浏览器中创建 XMLHttpRequests
+ 从 nodejs 创建 http 请求
+ 支持 Promise API
+ 有 interceptor 拦截器
+ 自动转换 JSON 数据
+ 客户端支持防御 XSRF，安全性高





