{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 前端笔记，GitBook 在线阅读 Github：https://github.com/yaozhongnan/note 其它阅读 「2019 JSConf.Asia - 尤雨溪」在框架设计中寻求平衡 再看2019大前端技术趋势，Web OS概念正落地 不要自称为程序员 React [译]React v16.9 新特性 虚拟 DOM 详解（一） 虚拟 DOM 详解（二） Vue 30 道 Vue 面试题 0 到 1 掌握：Vue 核心之数据双向绑定 Node.js Node.js：ubuntu安装Node.js Egg 一文看懂 Eggjs-基础全面讲解（中） 浏览器 浏览器的回流与重绘 (Reflow & Repaint) HTTP 为什么我们要熟悉这些通信协议？ 【精读】 彻底理解 cookie, session, token 博客 冴羽 前端瓶子君 ICSS，不止于 CSS 叶小钗 Mysql MySQL-mysql 8.0.11安装教程 MySQL数据库查询指令大全 commit gitbook build ./ ./docs git add . git commit -m 'messages' git push Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2020-03-19 15:54:55 "},"notes/Css.html":{"url":"notes/Css.html","title":"Css","keywords":"","body":"CSS 圣杯布局 两边固定 当中自适应 当中列要完整显示 当中列要优先加载 浮动:搭建完整的布局框架 margin 为负值（控制边界）:调整旁边两列的位置(使三列布局到一行上) --- 重点 使用相对定位:调整旁边两列的位置（使两列位置调整到两头） middle left right #wrap{ padding: 0 200px; } .middle { float: left; width: 100%; height: 100px; background-color: red; } .left{ position: relative; left: -200px; float: left; width: 200px; height: 100px; margin-left: -100%; /* 设置 -100% 让 left 盒子贴 middle 左侧 */ background-color: pink; } .right{ position: relative; right: -200px; float: left; width: 200px; height: 100px; margin-left: -200px; /* 设置 -200px 让 right 盒子贴 middle 右侧 */ background-color: green; } 等高布局 为上面的圣杯布局添加等高，就是让 left、right、middle 三个盒子等高，三个盒子始终以最高的盒子为高度保持等高 .middle,.left,.right{ padding-bottom: 10000px; margin-bottom: -10000px; /* 使用 margin 负值恢复边界控制 */ } 双飞翼布局 在圣杯布局的基础下，去掉了定位的使用和 wrap盒子的边距。改成给 middle 盒子在套一个内部 div ，给该 div 加上 padding 即可 middle BFC 实现两列布局 左边固定，右边自适应 在 IE 6 7中没有 BFC 的概念，但有一个 haslayout 概念，可以使用 zoom : 1 开启 haslayout left right .left { float: left; width:300px; height: 300px; background-color: pink; opacity: 0; } .right{ overflow: hidden; /* 核心：开启新的 BFC，利用 BFC 不会与浮动盒子重叠规则 */ height: 300px; background-color: red; } 实现多行文本溢出显示 ... .class{ width: 200px; /* 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性如下 */ -webkit-line-clamp: 3; /* 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 */ display: -webkit-box; -webkit-box-orient: vertical; /* 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 */ overflow: hidden; } 让图文不可复制 .class{ -webkit-user-select: none; -ms-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none; } 修改 placeholder 颜色 input::-webkit-input-placeholder { /* WebKit browsers */ font-size:14px; color: red; } input::-moz-placeholder { /* Mozilla Firefox 19+ */ font-size:14px; color: red; } input:-ms-input-placeholder { /* Internet Explorer 10+ */ font-size:14px; color: red; } Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/javascript/JavaScript.html":{"url":"notes/javascript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript 数据类型的转换 强制转换 强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。 Number() Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 String() String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 Boolean() Boolean函数可以将任意类型的值转为布尔值。 它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。 undefined null -0或+0 NaN ''（空字符串） 自动转换 遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。 第一种情况，不同类型的数据互相运算。 123 + 'abc' // \"123abc\" 第二种情况，对非布尔值类型的数据求布尔值。 if ('abc') { console.log('hello') } // \"hello\" 第三种情况，对非数值类型的值使用一元运算符（即+和-）。 + {foo: 'bar'} // NaN - [1, 2, 3] // NaN 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。 错误处理机制 JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 var err = new Error('出错了'); err.message // \"出错了\" Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError对象是解析代码时发生的语法错误。 ReferenceError对象是引用一个不存在的变量时发生的错误。 RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 ES6 知识点 Symbol 作为对象的属性只能通过 obj[symbol] 的形式添加，不能通过点的方式添加 原生具备 Iterator 接口的数据结构有：Array、Map、Set、String、TypedArray、Arguments、NodeList Set 数据结构：类似与数组，但它的成员都是唯一的 Map 数据结构：类似与对象，但它的 key 都是唯一的，且 key 不仅仅是字符串，任何类型的值都可以当 key 箭头函数没有 prototype 属性，没有 constructor，没有绑定 this DOM 一些节点的属性 每个节点都有 一个 childNodes 属性，其中保存着一个 NodeList 对象，NodeList 是一种类数组对象，用于保存一组有序的节点。具有 length 属性但不是 Array 的实例。NodeList 具有一个特点，它是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。 children 属性是 HTMLCollection 的实例，它只包含元素中同样还是元素的子节点 firstChild、firstElementChild lastChild、lastElementChild parentNode nextSibling、nextElementSibling previonsSibling、previonsElementSibling 节点操作 appendChild()，用于向 childNodes 列表的末尾添加一个节点，添加完成后返回该新增的节点 insertBefore(要插入的节点, 作为参照的节点)，插入到参照节点之前 replaceChild(要插入的节点，要替换的节点)，替换节点将会被移除 removeChild(要移除的节点)，移除节点 cloneNode(boolean)，传入 true 表示深克隆，false 浅克隆 normalize() apply()、call() 和 bind() 每个函数都有两个非继承而来的方法，apply() 和 call()，这两个方法的作用都是在特定的作用域中调用函数。 实际上等同于设置函数体内 this 对象的值。 window.color = \"red\"; var o = { color: \"blue\" }; function sayColor(){ alert(this.color); } sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue apply() 方法接收两个参数，第一个是在其中运行函数的作用域，第二个参数是数组。 call() 方法接收 n 个参数， 第一个是在其中运行函数的作用域，其余参数依次传入。 bind() 这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。 创建对象的几种方式 常见的创建对象的几种方式： 字面量的形式。例如： var obj = {} 调用系统的构造函数。例如：var obj = new Object() 自定义构造函数的方式。例： function Person(name, age) { this.name = name; this.age = age; this.sayHi = function () { alert('hello') } } vat per = new Person('yzn', 22) // 缺点：每个方法都要在每个实例上重新创建一遍 工厂模式创建对象：例： function createObj(name, age) { var obj = new Object() obj.name = name; obj.age = age; obj.sayHi = function () { alert('hello') } return obj } var per = createObj('yzn', 22) // 缺点：没有解决对象识别的问题（即怎么知道一个对象的类型） 原型模式 每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象，就是原型对象。原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 function Person() {} Person.prototype.name = 'yzn' Person.prototype.age = 22 Person.prototype.sayHi = function () { alert('hello') } // 缺点：不适合存储属性，特别是引用类型的属性 组合使用原型模式和构造函数模式 动态原型模式 寄生构造函数模式 稳妥构造函数模式 原型 原型：每当我们创建一个新函数，这个函数就会创建一个 prototype 属性，这个属性是一个指针，指向一个对象，就是函数的原型对象。 每一个原型对象都会有一个 constructor （构造函数）属性，该属性是一个指向 prototype 属性所在函数的指针 function Person() {} Person.prototype.constructor === Person // true 当我们创建一个构造函数的实例对象的时候 var p1 = new Person() 该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5 中管这个指针叫 [[Prototype]]，标准没有访问 [[Prototype]] 的方式，但各大浏览器在每一个实例对象上都支持一个属性 proto p1.__proto__ === Person.prototype // true 如果我们在一个实例中添加一个属性，而该属性与实例原型上的一个属性同名。那么该属性将会屏蔽原型上的那个属性。例： function Person() {} var p1 = new Person() p1.name = 'yzn' Person.prototype.name = 'lll' console.log(p1.name) // yzn delete p1.name // 可以使用 delete 操作符删除对象身上的属性 console.log(p1.name) // lll hasOwnProperty() 使用 hasOwnProperty() 可以检测一个一个属性存在与实例中还是原型中。当这个属性存在与实例中时返回 true function Person() {} var p1 = new Person() p1.name = 'yzn' Person.prototype.age = 23 console.log(p1.hasOwnProperty('name')) // true console.log(p1.hasOwnProperty('age')) // false in 使用 in 操作符也可以检测一个属性是否存在与一个对象中，但它不能检测出该属性在实例中还是原型中，因为但凡两者中有一个存在该属性，那么它就返回 true。例： function Person() {} var p1 = new Person() p1.name = 'yzn' Person.prototype.age = 23 console.log('name' in p1) // true console.log('age' in p1) // true 可以结合 in 操作符和 hasOwnProperty() 方法判断一个属性到底是存在与对象中，还是原型中。 for in 使用 for in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性。其中既包括存在与实例中的属性也包括存在与原型中的属性。 Object.keys() 使用 Object.keys() ，传入一个对象，返回一个包含该对象所有可枚举属性的字符串数组。 Object.getOwnPropertyNames() Object.getOwnPropertyNames()，传入一个对象，返回所有属性，无论是否可枚举。 继承 原型链实现继承 ES5 将原型链作为实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function () { return this.property; }; function SubType() { this.subproperty = false; } //继承了 SuperType，并且该写法相当于重写了 SubType 的原型对象，所以需要写在前面 // 让 SubType 的原型对象等于 new SuperType()，相当于等于了 SuperType 的实例对象，因此 SubType 的原型对象中就包含了 SuperType 的实例属性和方法。即 property 属性和 __proto__ 属性 SubType.prototype = new SuperType(); // 为 SubType 的原型对象上额外增加一个 getSubValue 属性，该属性值是一个方法 SubType.prototype.getSubValue = function () { return this.subproperty; }; var instance = new SubType(); console.log(instance); console.log(instance.getSuperValue()); //true 确定原型和实例的关系 方式一： instanceof 操作符 console.log(instance instanceof Object) // true console.log(instance instanceof SuperType) // true console.log(instance instanceof SubType) // true 方式二：isPrototypeOf() 方法 console.log(Object.prototype.isPrototypeOf(instance)) // true console.log(SuperType.prototype.isPrototypeOf(instance)) // true console.log(SubType.prototype.isPrototypeOf(instance)) // true 谨慎的定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎 样，给原型添加方法的代码一定要放在替换原型的语句之后。 原型链的问题 问题一：包含引用类型值的原型。 问题二：不能向超类型的构造函数中传递参数。 借用构造函数实现继承（经典继承） function SuperType(){ this.colors = [\"red\", \"blue\", \"green\"]; } function SubType(){ //继承了 SuperType SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green\" 通过使用 call()方法（或 apply()方法 也可以）“借调”了超类型中的构造函数。我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。 这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。 优点 可以向超类型中的构造函数传递参数 function SuperType(name){ this.name = name; } function SubType(){ //继承了 SuperType，同时还传递了参数 SuperType.call(this, \"Nicholas\"); //实例属性 this.age = 29; } 缺点 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 组合继承（伪经典继承） 组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数 复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ //继承属性 SuperType.call(this, name); this.age = age; } //继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){ alert(this.age); }; var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" instance1.sayName(); //\"Nicholas\"; instance1.sayAge(); //29 var instance2 = new SubType(\"Greg\", 27); alert(instance2.colors); //\"red,blue,green\" instance2.sayName(); //\"Greg\"; instance2.sayAge(); //27 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。 深浅拷贝 浅拷贝 复制一个对象，但复制的对象属性中不能是引用类型值的属性 var obj = { name: 'yzn', age: 12, address: '郑州', company: '民蕴', arr: [1, 2, 3] } var obj2 = obj function qiankaobei() { Object.keys(obj).forEach(item => { obj2[item] = obj[item] }) } qiankaobei() obj.arr.push(4) console.log(obj2); console.log(obj); 深拷贝 多复杂的对象都可以拷贝，且引用类型值的属性也没关系，且互不影响 var obj = { name: 'yzn', age: 12, address: 'zz', company: 'my', arr: [1, 2, 3, [2, 2, 2]], oo: { high: 188, cm: 'yyy', per: { cc: 22, zz: 'lll', arrc: ['2', 2, ['c', 'a']] } } } function deepCopy(current, target) { for (var key in current) { // 存当前 key 的 value 值 var value = current[key] // 如果这个值是数组类型 if (value instanceof Array) { // 让目标对象的当前 Key 为一个空数组 target[key] = [] // 递归进行拷贝 arguments.callee(value, target[key]) } else if (value instanceof Object) { // 让目标对象的当前 key 为一个空对象 target[key] = {} // 递归进行拷贝 arguments.callee(value, target[key]) } else { target[key] = value } } } var obj2 = {} deepCopy(obj, obj2) 堆和栈 栈：先进先出 堆：后进先出 执行环境及作用域 执行环境定义了变量或函数有权访问的其它数据，决定了它们各自的行为。 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的执行环境。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ES中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对 象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中 的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 执行上下文栈 1、在全局代码执行前，JS 引擎就会创建一个栈来存储管理所有的执行上下文对象 2、在全局执行上下文（window）确定后，将其添加到栈中（压栈） 3、在函数执行上下文创建后（每当函数被调用就会创建一个函数的执行上下文），将其添加到栈中（压栈） 4、在当前函数执行完后，将栈顶的对象移出（出栈） 5、当所有的代码执行完成后，栈中只剩下 window 注：栈的底部只可能是 window 闭包 闭包是指有权访问另一个函数作用域中的变量的函数 闭包有两种模式：函数模式的闭包和对象模式的闭包 闭包的作用：缓存数据，延长作用域链 闭包的优点和缺点均为缓存数据 // 函数模式的闭包 function f1() { var num = 10 function f2() { console.log(10) } f2() } f1() // 对象模式的闭包 function f1() { var num = 10 var obj = { age: num } console.log(obj.age) } f1() 当某个函数被调用时，会创建一个执行环境及响应的作用域链。然后，使用 arguments 和其它命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。 闭包的问题 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最 后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。 在闭包中使用 this 对象也可能会导致一些问题。 闭包会导致内存泄漏，例： function assignHandler(){ var element = document.getElementById(\"someElement\"); element.onclick = function(){ alert(element.id); }; } 事件流 事件流描述的是从页面中接收事件的顺序。 事件冒泡 IE 的事件流叫做事件冒泡（从里向外，div => body => html => Document） 事件捕获 网景的事件流叫做事件捕获（从外向里，Dodument => html => body => div） DOM 事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段 。首 先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段。 即 Dodument => html => body => div => body => html => Document target 和 currentTarget 的区别 当注册一个事件处理程序的时候，例： element.onclick = function (e) { console.log(e.target); console.log(e.currentTarget); } 事件对象的 target 和 currentTarget 属性有什么区别的？ target 是你点的那个 DOM 元素。 currentTarget 始终与事件处理函数中的 this 相同。 btn div.onclick = function(e) { console.log(e.target); console.log(e.currentTarget); } 垃圾收集 标记清除 引用计数 内存泄漏与内存溢出 内存泄漏： 占用的内存没有及时释放 内存泄漏积累的多了就容易导致内存溢出 哪些操作会造成内存泄漏 意外的全局变量 闭包引起的内存泄漏 没有清理的DOM元素引用 被遗忘的定时器或者回调 怎样避免内存泄漏 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 注意程序逻辑，避免“死循环”之类的 ； 避免创建过多的对象 原则：不用了的东西要及时归还。 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误 进程和线程 进程 程序的一次执行，它占有一片独有的内存空间 可以通过 windows 任务管理器查看进程 线程 是进程内的一个独立执行单元 是程序执行的一个完成流程 是 CPU 的最小调度单元 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/javascript/JavaScript Utils.html":{"url":"notes/javascript/JavaScript Utils.html","title":"JavaScript Utils","keywords":"","body":"JavaScript Utils 时间格式化 // formatDate(new Date().getTime());//2017-05-12 10:05:44 // formatDate(new Date().getTime(),'YY年MM月DD日');//2017年05月12日 // formatDate(new Date().getTime(),'今天是YY/MM/DD hh:mm:ss');//今天是2017/05/12 10:07:45 function formatDate(time,format='YY-MM-DD hh:mm:ss'){ var date = new Date(time); var year = date.getFullYear(), month = date.getMonth()+1,//月份是从0开始的 day = date.getDate(), hour = date.getHours(), min = date.getMinutes(), sec = date.getSeconds(); var preArr = Array.apply(null,Array(10)).map(function(elem, index) { return '0'+index; });////开个长度为10的数组 格式为 00 01 02 03 var newTime = format.replace(/YY/g,year) .replace(/MM/g,preArr[month]||month) .replace(/DD/g,preArr[day]||day) .replace(/hh/g,preArr[hour]||hour) .replace(/mm/g,preArr[min]||min) .replace(/ss/g,preArr[sec]||sec); return newTime; } 检测数据类型 Object.prototype.toString.call('此处传入要检测的数据') // 输出格式 例：[object Array] var type = function (o){ var s = Object.prototype.toString.call(o); return s.match(/\\[object (.*?)\\]/)[1].toLowerCase(); }; type({}); // \"object\" type([]); // \"array\" type(5); // \"number\" type(null); // \"null\" type(); // \"undefined\" type(/abcd/); // \"regex\" type(new Date()); // \"date\" var type = function (o){ var s = Object.prototype.toString.call(o); return s.match(/\\[object (.*?)\\]/)[1].toLowerCase(); }; ['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp' ].forEach(function (t) { type['is' + t] = function (o) { return type(o) === t.toLowerCase(); }; }); type.isObject({}) // true type.isNumber(NaN) // true type.isRegExp(/abc/) // true 格式化数字 function formatNum (num, n) { if (typeof num == \"number\") { num = String(num.toFixed(n || 0)); var re = /(-?\\d+)(\\d{3})/; while (re.test(num)) num = num.replace(re, \"$1,$2\"); return num; } return num; } console.log(formatNum(123456.1, 3)) // 123,456.100 // 格式化金钱，但不补零正则 var test1 = '1234567890' var format = test1.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') console.log(format) // 1,234,567,890 判断设备来源 function deviceType(){ var ua = navigator.userAgent; var agent = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; for(var i=0; i0){ break; } } } // 微信的 有些不太一样 function isWeixin(){ var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)=='micromessenger'){ return true; }else{ return false; } } 生成随机长度的字符串 function randomString(len = 32) { /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678' let pwd = '';　　 for (i = 0; i 判断是否为空对象 function isEmptyObject( obj ) { var name; for ( name in obj ) { return false; } return true; } console.log(isEmptyObject({})) // true 数组和对象的深拷贝 JSON.parse( JSON.stringify(param) ); 上传图片并预览 不兼容 IE 和 safari 等低版本浏览器 function previewImg(e){ // 单独检测 IE if (e.files === undefined) return alert('IE浏览器版本过低，不支持预览') // 用户重新上传时点击取消上传 bug，直接 return if (e.files[0] === undefined) return // 检测其余浏览器兼容性 if (!e.files[0] || !window.FileReader) return alert('您的浏览器不支持预览') // 得到上传的文件对象 var file = e.files[0]; // 验证图片格式 if (!/\\.(jpe?g|png|gif)$/i.test(file.name)) { return alert('图片格式不正确') } // 验证图片大小，默认不超过 1MB if (file.size > 1 * 1024 * 1024) { return alert('图片大小不能超过 1MB') } // 以上验证通过，则执行下方预览功能代码 // 创建 FileReader 实例 var reader = new FileReader() // 读取发生错误时触发 reader.addEventListener('error', function () { alert('读取文件时发生错误') }, false) // 读取文件完成时触发 reader.addEventListener('load', function () { // base64 存在 this.result 中 // 赋值给 预览图片的 src 即可 document.getElementById('imgId').src = this.result; }, false) // 转 base64，核心 reader.readAsDataURL(file); } 原生 ajax 封装 export default (type='GET', url='', data={}, async=true) => { return new Promise((resolve, reject) => { //定义一个promise type = type.toUpperCase(); let requestObj; if (window.XMLHttpRequest) { requestObj = new XMLHttpRequest(); } else { requestObj = new ActiveXObject; } if (type == 'GET') { let dataStr = ''; //数据拼接字符串 Object.keys(data).forEach(key => { dataStr += key + '=' + data[key] + '&'; }) dataStr = dataStr.substr(0, dataStr.lastIndexOf('&')); url = url + '?' + dataStr; requestObj.open(type, url, async); requestObj.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); requestObj.send(); }else if (type == 'POST') { requestObj.open(type, url, async); requestObj.setRequestHeader(\"Content-type\", \"application/json\"); requestObj.send(JSON.stringify(data)); }else { reject('error type'); } requestObj.onreadystatechange = () => { if (requestObj.readyState == 4) { if (requestObj.status == 200) { let obj = requestObj.response if (typeof obj !== 'object') { obj = JSON.parse(obj); } resolve(obj); }else { reject(requestObj); } } } }) } 获取浏览器视口大小 function getViewport() { if (document.compatMode == \"BackCompat\") { return { width: document.body.clientWidth, height: document.body.clientHeight }; } else { return { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight }; } } 获取元素的左和上偏移量 function getElementLeft(element) { var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null) { actualLeft += current.offsetLeft; current = current.offsetParent; } return actualLeft; } function getElementTop(element) { var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null) { actualTop += current.offsetTop; current = current.offsetParent; } return actualTop; } 确定元素大小 借助了 getElementLeft 与 getElementTop 方法 function getBoundingClientRect(element) { var scrollTop = document.documentElement.scrollTop; var scrollLeft = document.documentElement.scrollLeft; if (element.getBoundingClientRect) { if (typeof arguments.callee.offset != \"number\") { var temp = document.createElement(\"div\"); temp.style.cssText = \"position:absolute;left:0;top:0;\"; document.body.appendChild(temp); arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; document.body.removeChild(temp); temp = null; } var rect = element.getBoundingClientRect(); var offset = arguments.callee.offset; return { left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset }; } else { var actualLeft = getElementLeft(element); var actualTop = getElementTop(element); return { left: actualLeft - scrollLeft, right: actualLeft + element.offsetWidth - scrollLeft, top: actualTop - scrollTop, bottom: actualTop + element.offsetHeight - scrollTop } } } 获取元素的宽高 // 参数一：要获取的元素 Dom // 参数二：布尔值，是否要加上边框 function getElementSize(element, border) { return { width: border ? element.offsetWidth : element.clientWidth, height: border ? element.offsetHeight : element.clientHeight } } 正则 手机号 /^1((3[\\d])|(4[5,6,9])|(5[0-3,5-9])|(6[5-7])|(7[0-8])|(8[1-3,5-8])|(9[1,8,9]))\\d{8}$/ 大写字母 /^[A-Z]+$/ 日期,如: 2000-01-01 /^\\d{4}(-)\\d{1,2}\\1\\d{1,2}$/ email地址 /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/ 国内座机电话,如: 0341-86091234 /\\d{3}-\\d{8}|\\d{4}-\\d{7}/ 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线组合 /^[a-zA-Z][a-zA-Z0-9_]{4,15}$/ 只包含中文 /^[\\u4E00-\\u9FA5]/ 是否小数 /^\\d+\\.\\d+$/ 是否电话格式(手机和座机) /^((0\\d{2,3}-\\d{7,8})|(1[345789]\\d{9}))$/ 是否8位纯数字 /^[0-9]{8}$/ 是否html标签 /.*|/ 是否qq号格式正确 /^[1-9]*[1-9][0-9]*$/ 是否由数字和字母组成 /^[A-Za-z0-9]+$/ 是否小写字母组成 /^[a-z]+$/ 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符 /^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/ 用户名正则，4到16位（字母，数字，下划线，减号） /^[a-zA-Z0-9_-]{4,16}$/ ipv4地址正则 /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ 16进制颜色 /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/ 微信号，6至20位，以字母开头，字母，数字，减号，下划线 /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/ 中国邮政编码 /^(0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\\d{4}$/ 只包含中文和数字 /^(([\\u4E00-\\u9FA5])|(\\d))+$/ 非字母 /[^A-Za-z]/ Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/javascript/JavaScript 深入.html":{"url":"notes/javascript/JavaScript 深入.html","title":"JavaScript 深入","keywords":"","body":"JavaScript 深入 为何会发生变量提升，函数提升 js 引擎在执行 Js 代码时并非一行一行执行，而是一段一段执行，当执行一段代码时，会创建当前代码段环境的执行上下文，然后做一些准备工作。 先来说下什么叫一段一段的代码，其实就是可执行代码（executable code），全局代码，函数代码和 eval 代码。 那么这个准备工作又是什么意思呢？ 实际上 js 引擎在分析代码的时候，分为两个阶段：编译阶段和执行阶段，这里的编译阶段与 c 中将高级语言转换为机器语言不同，这里的编译就可以理解为准备工作。 编译阶段：只会处理声明语句，会将所有声明的变量添加为当前执行上下文变量对象（VO）的属性。如果是变量声明，其值暂时初始化为 undefined，如果是函数声明，它会在堆上开辟内存，并将函数定义放在堆上，函数变量只保存指向函数定义的地址。 执行阶段：编译结束后，js 引擎会再次扫描代码，这个阶段主要的任务的根据执行的语句，更新变量对象等。 之所以会发生变量提升，函数提升，就是 js 引擎在编译阶段只处理声明语句的缘故。 注意：进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 让我们用一个例子来看看 js 的执行顺序，有以下代码： function foo() { console.log(a); } var a = 10; foo(); 执行步骤，伪代码： // 进入全局代码段，创建全局执行上下文对象。js 引擎进入编译阶段 globalContext = {} // 处理全局环境中的声明语句，函数声明和变量声明.添加到全局执行上下文对象 VO 中 globalContext = { VO: { foo: 0x0000, // 保存函数定义的地址 a: undefined // 变量声明初始值一律为 undefined } } // 语句声明处理完成，进入执行阶段 // 发现执行语句 var a = 10 globalContext = { VO: { foo: 0x0000, a: 10 } } // 发现执行语句 foo()，执行函数，函数中打印变量 a，由于函数内部找不到变量 a，因此去全局执行上下文里找，找到 a，打印 10 在用一个例子看看变量提升和函数提升： console.log(foo); var foo = 1; console.log(foo); function foo() { console.log('foo'); } /* 分析： 进入编译阶段：首先进行函数提升，在进行变量提升，由于变量提升时发现重名，但变量声明并不会干扰已经提升的函数声明，因此此时的 foo 仍是函数 执行阶段：执行第一个 console，由于这时 foo 是函数，因此打印函数 执行第二行语句，将 foo 变量赋值给 1，相当于把原先的 foo 函数改写为了 1 执行第二个 console，由于 foo 函数以及被改写为 1，因此打印 1 */ 例子： foo(); if (true) { function foo() { console.log('1111'); } } else { function foo() { console.log('22222'); } } /* 分析： 如果照常分析的话 foo 函数调用应该会打印 22222，然而实际上却是报错 这是因为这里的函数声明都放在的代码块中，js 引擎不将代码块中的函数声明进行提升，而是处理成了函数表达式，函数表达式自然是不会提升的 */ 经典面试题： var c = 1; function c() { console.log(c); } c(); /* 分析： 首先进行变量提升与函数提升，由于重名，因此存下来的为函数 c 然后开始执行代码，执行第一行，将 c 赋值为 1，这意味着 c 从函数变成了 1 继续执行到第四行，c 调用，由于此时的 c 已经变成了 1，因此报错 c is not a function */ 执行上下文栈 我们知道，每执行一个函数的时候，就会创建函数的一个执行上下文，那我们写的那么多函数，创建的那么多执行上下文如何管理呢？ 所以 js 引擎创建了执行上下文栈（execution context stack, ECS）来管理执行上下文。 执行上下文栈的特点在此不在赘述 执行上下文 当 js 遇到一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性 变量对象（varialbe object, VO）、作用域链（scope chain）、this 变量对象 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明 全局执行上下文 很明显，全局执行上下文的变量对象就是全局对象，而全局对象就是 window 对象 函数执行上下文 在函数执行上下文中，我们用活动对象（activation object AO）来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。 它们其实都是同一个对象，只是处于执行上下文的不同生命周期。 函数执行上下文的代码会分为两个阶段进行：分析和执行阶段，也可以叫进入执行上下文和代码执行阶段 进入执行上下文阶段与 js 引擎的编译阶段相似，不仅处理了函数和变量声明，还有函数的所有形参 举个例子，有以下代码： function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); 在进入执行上下文后，这时候的 AO 是： AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 当进入代码执行阶段时，AO 为： AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression \"d\" } 作用域链 函数的作用域在函数定义的时候就决定了。这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中。 在源代码中当你定义（书写）一个函数的时候（并未调用），js引擎也能根据你函数书写的位置，函数嵌套的位置，给你生成一个[[scope]]，作为该函数的属性存在（这个属性属于函数的）。即使函数不调用，所以说基于词法作用域（静态作用域）。 然后进入函数执行阶段，生成执行上下文，执行上下文你可以宏观的看成一个对象，（包含vo,scope,this），此时，执行上下文里的scope和之前属于函数的那个[[scope]]不是同一个，执行上下文里的scope，是在之前函数的[[scope]]的基础上，又新增一个当前的AO对象构成的。 函数定义时候的[[scope]]和函数执行时候的scope，前者作为函数的属性，后者作为函数执行上下文的属性。 call 方法的模拟实现 call 方法的模拟实现之前，我们需要认识以下原生的 call 方法到底具有哪些特点，只有清楚这些特点，才能更完整的模拟实现。 call 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 call 的第一个参数，指定了函数内部的 this 指向，可以为 Null，为 null 时视为 window，后续的参数与函数接收的参数一一对应 函数可以有返回值的 call 方法还可以理解为借用函数，借用了这个函数给指定的 this 对象使用，用完就完事儿了。 基于以上特点，ES5 模拟实现如下： Function.prototype.call2 = function(context) { // 传了 context 则为 context，传 null 视为 window context = context || window; // 获取传递的参数，需要剔除第一个参数 this，以数组形式保存 var args = Array.prototype.slice.call(arguments, 1); // 借用函数，绑定函数为自身的一个属性，这里的 this 就是那个函数 context.__fn__ = this; // 这里有一个小问题，就是 context 可能本来就存在 __fn__ 属性 // 调用函数，并将参数传入，使用 eval 调用，要考虑有返回值 var result = eval('context.__fn__('+ args +')'); // 借用完成，删除该属性 delete context.__fn__; return result; } ES6 模拟实现如下： Function.prototype.call2 = function(context, ...args) { context = context || window; const fn = Symbol(); context[fn] = this; context[fn](...args) delete context[fn]; return result; } bind 方法的模拟实现 首先要清楚 bind 有哪些特点，bind 和 call 方法的区别就是 bind 返回一个函数并不调用，call 会调用 然后 bind 返回的方法还可以使用 new 创建实例对象 bind 传递的参数可以只传一部分，另一部分参数可以在调用函数的时候接着传递 Function.prototype.bind2 = function (context) { // 检查 bind 绑定的是不是函数，不是函数的话报错 if (typeof this !== \"function\") { throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); } // 拿到绑定函数 var self = this; // 获取绑定时传递的参数，需要截掉第一个参数 var args = Array.prototype.slice.call(arguments, 1); // 创建一个空函数 var fNOP = function () {}; // fBound 就是最终要返回的函数 var fBound = function () { // 获取绑定函数调用时传递的参数 var bindArgs = Array.prototype.slice.call(arguments); // fBound 内部执行绑定函数，并根据 this 是否为 fBound 的实例来决定 this 的值，同时传入合并后的参数 return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); } // 让空函数 fNOP 的原型指向绑定函数的原型 // 之所以没有让 fBound.prototype 直接等于 this.prototype 是因为当 fBound.prototype 改变时 this.prototype 也会改变，因此利用空函数中转 fNOP.prototype = this.prototype; // 让返回的函数原型为 fNOP 的实例原型 fBound.prototype = new fNOP(); return fBound; } new 的模拟实现 new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 new 返回一个对象，并且该对象的隐式原型属性指向构造函数的 prototype 注意：构造函数中可能会存在返回值，返回对象与返回基本类型的值完全不一样 function mockNew() { var obj = new Object(); var Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj; } 创建对象的多种方式 最常见的有工厂模式、构造函数模式、原型模式、组合模式（构造函数与原型模式结合），还有动态原型模式、寄生构造函数模式、稳妥构造函数模式 这里要讲的是寄生构造函数模式，代码如下： function Person(name) { var o = new Object(); o.name = name; o.getName = function () { console.log(this.name); }; return o; } 看到函数名 Person，构造函数，再看函数内部，工厂模式啊。所以寄生构造函数模式就是打着构造函数的名义干着工厂模式的事儿，典型的挂羊头卖狗肉 继承的多种方式 原型链继承 直接让子类的 prototype 等于父类的实例对象，这样就共享了父类的属性和方法 但是缺点是如果父类中的属性值是引用类型，则被所有实例所共享，且子类无法传参给父类 Child.prototype = new Parent() 借用构造函数（经典继承） 子类构造函数里调用父类构造函数，借用一下，解决了原型链继承中属性值是引用类型的问题 这样可以向父类传参，但好像无法共享父类原型的方法，而是讲方法定义在了构造函数中 function Child () { Parent.call(this); } 组合继承 原型链继承和经典继承结合。 缺点：调用了两次父类的构造函数 function Child () { Parent.call(this); // 1 次 } Child.prototype = new Parent() // 2 次 Child.prototype.constructor = Child; 寄生组合式继承 解决了组合继承中父类构造函数调用两次的问题 function Parent (name) { this.name = name; this.colors = ['red', 'blue', 'green']; } Parent.prototype.getName = function () { console.log(this.name) } function Child (name, age) { Parent.call(this, name); this.age = age; } // 关键的三步 var F = function () {}; F.prototype = Parent.prototype; Child.prototype = new F(); var child1 = new Child('kevin', '18'); console.log(child1); 惰性函数 DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断： 不使用惰性函数，每次调用 addEvent 事件均会进行判断 function addEvent (type, el, fn) { if (window.addEventListener) { el.addEventListener(type, fn, false); } else if(window.attachEvent){ el.attachEvent('on' + type, fn); } } 使用惰性函数，只有初次调用会进行判断，之后再次调用由于方法被重写，不会再判断 function addEvent (type, el, fn) { if (window.addEventListener) { el.addEventListener(type, fn, false); addEvent = function (type, el, fn) { el.addEventListener(type, fn, false); } } else if(window.attachEvent){ el.attachEvent('on' + type, fn); addEvent = function (type, el, fn) { el.attachEvent('on' + type, fn); } } } 方法内部只执行一次 有时候我们会遇到这样的场景，就是函数内部的代码只在初次调用的时候执行，往后在调用都不执行 以下所有示例，console.log(2) 就是我们想要执行的代码，只在初次执行时运行 以前的常用方法： // 声明一个全局变量作为标志 var flag = true; function foo() { if (flag) { console.log(2); } flag = false; } foo() foo() 也可以用闭包来解决，以免污染全局 var foo = (function() { var flag = true; return function() { if (flag) { console.log(2); } flag = false; } })(); foo() foo() 还可以利用函数也是对象的特性： function foo() { if (!foo.flag) { console.log(2); } else { foo.flag = true; } } 利用惰性函数 var foo = function() { console.log(2); foo = function() { return; }; return foo(); }; Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/vue/Vue.html":{"url":"notes/vue/Vue.html","title":"Vue","keywords":"","body":"Vue 移动端项目笔记 1 vue-router 相关 1.1 如何获取路由中的参数 每一个vue实例身上都有一个属性： $route ，该属性是路由里的参数对象，其身上有一个 params 属性，如下方式获取 Vue.$route.params.id //获取路由中的 id 参数值 1.2 获取文章的详细内容数据时，图片显示异常 解决方案：将图片的 width 属性设置为 100% （如果没有解决，需要删除 style 标签中的 scoped 属性） 1.3 编程式的导航 在每一个 vue 实例上，都存在一个 $router 属性，该属性是路由里的导航对象；$router 为 VueRouter 实例，想要导航到不同URL，则使用 $router.push 方法 // 使用方式一： 传入一个字符串 // 其中传入 push 中的字符串就是路由中的 path 属性值 this.$router.push('/home/goodsinfo' + id) // 使用方式二： 传入一个对象 // 其用法仅仅改为传入了 path 对象 this.$router.push({ path: '/home/goodsinfo' + id }) // 使用方式二： 传入命名的路由 // 其用法需规定路由的 name 属性，参数通过 params 获得 this.$router.push({ name: 'goodsinfo', params: { id: id } }) 2 组件相关 2.1 什么的组件 组件的出现是为了拆分 Vue 实例的代码量，能够让我们以不同的组件来划分不同的功能模块 2.2 组件化和模块化的区别 模块化：是从代码逻辑角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化：是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 2.3 父组件向子组件传递参数 父组件向子组件传递参数需要在使用子组件的标签上绑定该参数，例： 子组件想要使用父组件传递过来的参数，需要接受该参数 new Vue({ props: ['id'] //在 vue 实例中使用 props 接收该参数，并使用 this.id 使用它 }) 2.4 子组件向父组件传递参数 采用事件调用机制，即父组件定义一个方法，并将该方法传递给子组件，子组件接收并调用该方法，将需要传递的数据以参数的形式传递给父组件。例： 父组件中 methods: { getData(data){ this.mydata = data //可以将传递过来的值保存在自己的 data 中 } } 子组件中 // 子组件可以使用 $emit 触发父组件的自定义事件 // 第一个参数为触发的事件名称，第二个参数为需要传递的参数 this.$emit('getData', data) 3 相关插件的使用 3.1 时间日期插件 Moment.js 使用方法： // 安装插件 npm i moment -S // 导入该插件 import moment from 'moment' //定义全局时间格式化过滤器 Vue.filter('dataFormat', function(datastr, pattern = \"YYYY-MM-DD HH:mm:ss\"){ return moment(datastr).format(pattern); }) 官方网站： http://momentjs.cn/ 3.2 图片查看器 Vue preview 使用方法： //安装插件（此处使用的是1.0.5版本） npm i vue-preview@1.0.5 -S //导入和挂载插件 import VuePreview from 'vue-preview' Vue.use(VuePreview) // html 部分 注意：此处的数据名称只能使用 list , 不能使用其它名称 // javascript 部分 data:{ list:[ { src: 'xxxx.jpg', w: 600, h: 400 }, { src: 'xxxx.png', w: 600, h: 400 } ] } 官方 github 地址：https://github.com/LS1231/vue-preview 3.3 禁用 webpack 的严格模式 使用插件 babel-plugin-transform-remove-strict-mode 安装 npm install babel-plugin-transform-remove-strict-mode .babelrc { \"plugins\": [\"transform-remove-strict-mode\"] } Via CLI $ babel --plugins transform-remove-strict-mode script.js Via Node API require(\"babel-core\").transform(\"code\", { plugins: [\"transform-remove-strict-mode\"] }); github地址 https://github.com/genify/babel-plugin-transform-remove-strict-mode 4 动画相关 Vue 中的动画分为三段 v-enter 和 v-leave-to 初始阶段 v-enter-to 和 v-leave 结束阶段 v-enter-active 和 v-leave-active 运行阶段 4.1 基本使用 Document .box{ width: 100px; height: 100px; background: red; } /* 初始阶段 - 透明度为 0，从 200px 位置进入 */ .v-enter, .v-leave-to{ opacity: 0; transform: translateX(200px); } /* 运行阶段 设置过渡 */ .v-enter-active, .v-leave-active{ transition: all .4s ease ; } /* 离开阶段 - 透明度为 1 */ .v-leave, .v-enter-to{ opacity: 1; } 按钮 也可以把基类放到元素身上，这样 transition 身上则不需要放置基类 --> var vm = new Vue({ el: '#app', data: { flag: false }, methods: { } }) 4.2 JavaScript 钩子 半场动画案例 data: { flag: false } methods: { // -------- // 进入中 // 钩子函数的第一个参数都是 el，表示要执行动画的那个DOM参数，是个原生的JS DOM对象 // -------- beforeEnter: function (el) { // 可以在此处设置动画开始之前的起始位置 el.style.transform = \"translate(0,0)\" }, enter: function (el, done) { // 动画若想实现过渡，必须加上 el.offsetWidth el.offsetWidth // 此处表示动画开始之后的样式，这里可以设置小球完成动画之后的结束状态 el.style.transform = \"translate(150px,150px)\" el.style.transition = \"all 1s ease\" // 这里的 done 其实就是 afterEnter 函数，也就是说 done 是 afterEnter 函数的引用 done() }, afterEnter: function (el) { // 表示动画完成之后 this.flag = !this.flag }, enterCancelled: function (el) { // 进入关闭，一般用不到 }, // -------- // 离开时 // -------- beforeLeave: function (el) { // ... }, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) { // ... done() }, afterLeave: function (el) { // ... }, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) { // ... } } 4.3 列表过渡 如果需要过渡的元素是通过 v-for 循环渲染出来的，则不能使用 transtion 包裹，需要使用 transtion-group 如果想要动画效果更佳流畅，需要指定两个类，能够实现列表后续的元素渐渐的飘上来的效果 .v-move{ transition: all .6s ease ; } .v-leave-active{ position: absolute ; } 给 transtion-group 标签加上 appear 属性，可以实现入场时的效果 可以给 transtion-group 添加 tag 属性，指定将来要渲染的元素，如果不指定，默认渲染为 span 5 其它 5.1 $refs 对象 该对象持有注册过 ref 特性的所有 DOM 元素和组件实例 用法 methods: { changeMethods(){ // 这里通过 this.$refs.inp 拿到原生 dom 对象 就可以使用 value 获取该值 console.log(this.$refs.inp.value) } } 5.2 watch watch - 侦听属性，用来观察和响应 Vue 实例上的数据变动 var vm = new Vue({ data： { count: 1 }, watch: { // 监听 count 值，改变时发生的回调，接收两个参数，分别为新值和旧值 'count': function(newVal, oldVal){ // 当 count 值发生变化时发生的操作 } } }) 5.3 vuex 概念：vuex 是 Vue 配套的公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或修改我们的公共数据 5.3.1 安装步骤 1 - 安装： npm install vuex --save 2 - 在一个模块化的打包系统中，必须显式地通过 Vue.use() 来安装 Vuex： import Vue from 'vue' import Vuex from 'vuex' // 注册 vuex 到 Vue 实例中 Vue.use(Vuex) 3 - new Vuex.Store() 实例，得到一个数据仓储对象 const store = new Vuex.Store({ state: { // 可以把 state 想象成组件中的 data，专门用来存储数据的 }, mutations: { // 存放一些方法，用于修改 state 中的数据 }, getters: { // 只负责对外提供数据，不负责修改数据，如果想要修改 state 中的数据，使用 mutations } }) 4 - 将 vuex 创建的 store 挂载到 vue 实例上 var vm = new Vue({ data: {}, methods: {}, store: store // 也可简写为 store }) 5.3.2 使用 state 中的数据 如果想要在组件中访问 store 中的数据，只能通过 this.$store.state.xxx 来访问。 只要挂载了 store 到 vm 实例上，任何组件都能使用 store 来存取数据。 5.3.3 使用 mutations 中的方法 如果要操作 store 中的 state 值，只能通过调调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 state 中的数据，因为万一导致了数据的紊乱，不能快速定位到错误的原因，因为每个组件都可能有操作数据的方法 // 例：有一个仓储 store，其中存储了一个 count 数据和一个 increment 方法，该方法每次被调用时会把 state 中的 count 值增加 1 const store = new Vuex.Store({ state: { count: 0 }, mutations: { // 注：mutations 中定义的方法只能接收两个参数 // 参数1：被规定死，必须为 state // 参数2：是通过 commit 提交过来的参数，提交过来的参数可以是对象、字符串、数值 increment(state){ state.count ++ } } }) 组件中如何使用 store 中 mutations 里的方法： // 组件中如果想要使用 mutations 中的方法，只能使用 this.$store.commit('方法名') var vm = new Vue({ methods: { add(){ // 调用 store 实例中的 mutations 中的 increment 方法 this.$store.commit('increment') } } }) 5.3.4 使用 getters // 例： const store = new Vuex.Store({ state: { count: 0 }, getters: { // 每一个 getters 的属性值都是一个方法，该方法的第一个参数必须为 state // 只要 state 中的数据发生了变化，那么如果 getters 正好也引用了这个数据，就会立即触发 getter 重新求值 optCount: function(state){ return '当前最新的count值是：' + 'state.count' } } }) 组件中如何使用 store 中 getters : this.$store.getters.xxx # 其它知识点 # vue-router 的 post 请求 使用 post 发送数据请求时：需要传入的参数有三个 参数1：请求的 URL 地址 参数2：提交给服务器的数据对象 { content: this.msg } 参数3：定义提交的时候，表单中数据的格式 { emulateJSON: true } 可以将第三个参数配置为全局 Vue.http.options.emulateJSON = true // post 请求书写格式 this.$http.post(参数1，参数2，参数3).then(function(result){ console.log(result.body) }) # 将项目托管到码云上 在项目目录下运行 git init 使用 git add . 将文件放入 站内区 使用 git commit -m \"这是描述\" 将项目提交至本地仓库 可以使用 git status 命令查看所有文件的状态（标红的代表未提交） 如何查看自己的电脑是否拥有公钥：进入c://用户/用户名/ 下检查是否有 .ssh 文件夹 git remote add origin https://gitee.com/zahirah/vue-app.git # 使用字体图标 @font-face{ font-family: 'myicon'; /* 自定义名称 */ src: url('../font/xxx.eot') format('embedded-opentype'), url('../font/xxx.svg') format('svg'), url('../font/xxx.ttf') format('truetype'), url('../font/xxx.woff') format('woff'); /* 字体文件路径 - 引入顺序，eto > svg > ttf > woff */ } /* 给所有已 icon- 开头的类名设置该字体 */ [class^ = 'icon-'], [class* = ' icon-']{ font-family: 'myicon' ; font-style: normal ; /* 设置斜体为正常 */ } Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/vue/Vuex.html":{"url":"notes/vue/Vuex.html","title":"Vuex","keywords":"","body":"Vuex 文档手册 单向数据流 state，驱动应用的数据源； view，以声明方式将 state 映射到视图； actions，响应在 view 上的用户输入导致的状态变化。 用户在 view 上进行一些 actions 动作，该动作改变了 state 状态，然后再根据状态改变视图 // 用户单击按钮改变状态 btn.onclick = function () { state.name = 'yyy' } 双向数据流 用户在 view 上进行一些操作上，state 同步改变，无需改变视图 State 当我们需要调用 store 中的状态时，通常需要使用 this.$store.state.xxx 获取该值 或者通过 vue 提供的计算属性得到该状态值 computed: { count () { return this.$store.state.count } } 当我们需要调用 vuex 中的多个状态时，计算属性就会变的重复冗余，因此 vuex 提供一个辅助函数 mapState() mapState 使用方式一： 由于 mapState 方法返回一个对象 import { mapState } from 'vuex' computed: mapState({ // 箭头函数可使代码更简练 count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) 使用方式二： 当计算属性的名称和 state 的子节点名称相同时 // 传入一个字符串数组 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) 使用方式三： 对象展开运算符，解决 mapState 与计算属性混用 computed: { localComputed () { /* ... */ }, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState({ // ... }) } Getter 有时我们需要从 store 中的 state 中派生出一些状态，并不想改变原 state 值，因此可以使用 Getters，它就像计算属性一样，getters 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变时才会重新计算 getters: { // getters 接收 state 作为第一个参数 doneTodos: state => { return state.todos.filter(todo => todo.done) } } Getter 也可以接受其他 getter 作为第二个参数： getters: { // ... doneTodosCount: (state, getters) => { return getters.doneTodos.length } } 通过属性调用 this.$store.getters.doneTodos 通过方法调用 getters: { // ... getTodoById: (state) => (id) => { return state.todos.find(todo => todo.id === id) } } store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false } 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果 mapGetters mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } } 如果你想将一个 getter 属性另取一个名字，使用对象形式： mapGetters({ // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount' }) Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation， 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： store.commit('increment') 提交载荷（Payload） 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： // ... mutations: { increment (state, n) { state.count += n } } store.commit('increment', 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： // ... mutations: { increment (state, payload) { state.count += payload.amount } } store.commit('increment', { amount: 10 }) 对象风格的提交方式 提交 mutation 的另一种方式是直接使用包含 type 属性的对象： store.commit({ type: 'increment', amount: 10 }) 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变： mutations: { increment (state, payload) { state.count += payload.amount } } Mutation 需遵守 Vue 的响应规则 既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写： state.obj = { ...state.obj, newProp: 123 } 使用常量替代 Mutation 事件类型 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： // mutation-types.js export const SOME_MUTATION = 'SOME_MUTATION' // store.js import Vuex from 'vuex' import { SOME_MUTATION } from './mutation-types' const store = new Vuex.Store({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } } }) 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 必须是同步函数 一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子： mutations: { someMutation (state) { api.callAsyncMethod(() => { state.count++ }) } } 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 mapMutations 你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 import { mapMutations } from 'vuex' export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } } 下一步：Action 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务： store.commit('increment') // 任何由 \"increment\" 导致的状态变更都应该在此刻完成。 为了处理异步操作，让我们来看一看 Action。 Action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action： const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： actions: { increment ({ commit }) { commit('increment') } } 分发 Action Action 通过 store.dispatch 方法触发： store.dispatch('increment') 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } Actions 支持同样的载荷方式和对象方式进行分发： // 以载荷形式分发 store.dispatch('incrementAsync', { amount: 10 }) // 以对象形式分发 store.dispatch({ type: 'incrementAsync', amount: 10 }) 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () => commit(types.CHECKOUT_SUCCESS), // 失败操作 () => commit(types.CHECKOUT_FAILURE, savedCartItems) ) } } 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。 在组件中分发 Action 你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } 组合 Action Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： actions: { actionA ({ commit }) { return new Promise((resolve, reject) => { setTimeout(() => { commit('someMutation') resolve() }, 1000) }) } } 现在你可以： store.dispatch('actionA').then(() => { // ... }) 在另外一个 action 中也可以： actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() => { commit('someOtherMutation') }) } } 最后，如果我们利用 async / await，我们可以如下组合 action： // 假设 getData() 和 getOtherData() 返回的是 Promise actions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) } } 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/react/React.html":{"url":"notes/react/React.html","title":"React","keywords":"","body":"React 核心概念 虚拟DOM（Virtual Document Object Model） DOM 的本质是什么：浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作 DOM 对象的API； 什么是 React 中的虚拟 DOM：是框架中的概念，是程序员用JS对象来模拟页面上的 DOM 和 DOM 嵌套； 为什么要实现虚拟 DOM（虚拟 DOM 的目的）：为了实现页面中， DOM 元素的高效更新 DOM 和虚拟 DOM 的区别： DOM：浏览器中，提供的概念；用 JS 对象，表示页面上的元素，并提供了操作元素的 API； 虚拟 DOM：是框架中的概念；而是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系； 本质： 用 JS 对象，来模拟 DOM 元素和嵌套关系； 目的：就是为了实现页面元素的高效更新；Diff 算法 tree diff: 新旧两棵DOM树，逐层对比的过程，就是 Tree Diff； 当整颗 DOM 逐层对比完毕，则所有需要被按需更新的元素，必然能够找到； component diff：在进行 Tree Diff 的时候，每一层中，组件级别的对比，叫做 Component Diff； 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新； 如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上； element diff: 在进行组件对比的时候，如果两个组件类型相同，则需要进行 元素级别的对比，这叫做 Element Diff； 一些知识点 setState() 的调用是异步的，不要在调用 setState() 之后，紧接着依赖 this.state 来反射新值 当组件中的 state 数据发生变化，则组件会重新调用 render 函数。父组件中的 props 发生变化，则子组件也会重新调用 render 函数。 react 中绑定事件传递参数的两种方式（注意使用 bind 传参时 e 对象要放在最后使用，但无需传递） this.deleteRow(id, e)}>Delete Row Delete Row react 中阻止事件默认行为只能通过 e.preventDefault() 的方式。 无状态组件与有状态组件的区别就在于是否拥有自己的 state。 在 React 中，使用组件的组合，而非继承 本质上来讲，JSX 只是为 React.createElement(component, props, ...children)方法提供的语法糖 diffing 算法用来找出两棵树的所有不同点 受控组件 受控组件基本是一些 HTML 的表单元素，类似 Input, select, textarea 等。它们都会维持各自的状态。 但在 React 中，可变的状态是保存在 state 中的，并且更新只能使用 setState() 方法。 因此结合两者， React 负责渲染表单的组件仍然控制着用户后续输入所发生的变化，但值由 React 控制的输入表单元素称为受控组件 简而言之：值由 React 的 state 管理的表单元素称为受控组件 非受控组件 在大多情况下，推荐使用受控组件来实现表单，表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案是使用非受控组件。 要编写一个非受控组件，而非为每个状态更新编写事件处理程序，可以使用 ref 从 DOM 获取表单值。 render() { return ( Name: this.input = input} /> // 这时 this.input 就是该 dom 元素 ); } 在React中， 始终是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。 shouldComponentUpdate 钩子 shouldComponentUpdate 这个生命周期函数控制了组件是否应该被更新，也就是执不执行 render 函数 这个生命周期函数返回一个布尔值，如果返回 true，则当 props 或 state 改变的时候会重新 render，反之不会 因此，重写 shouldComponentUpdate 函数可以提升性能。因为它是在 render 前触发的。 注意：shouldComponentUpdate 默认返回 ture class CounterButton extends React.Component { constructor(props) { super(props); this.state = {count: 1}; } shouldComponentUpdate(nextProps, nextState) { // 根据 props 和 state 的变化决定返回 ture 还是 false if (this.props.color !== nextProps.color) { return true; } if (this.state.count !== nextState.count) { return true; } return false; } render() { return ( this.setState(state => ({count: state.count + 1}))} > Count: {this.state.count} ); } } React.PureComponent 我们可以在创建组件时选择继承 React.PureComponent class MyComponent extends React.PureComponent { // some codes here } 它和继承自普通 Component 的区别是： 继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告 继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致 比较会忽略属性或状态突变的情况，其实也就是，数据引用指针没变而数据被改变的时候，也不新渲染组件。但其实很大程度上，我们是希望重新渲染的。所以，这就需要开发者自己保证避免数据突变。 注：PureComponent 需要依靠 class 创建的组件才可以使用 React.memo() React.memo() 和 PureComponent 很相似，它帮助我们控制何时重新渲染组件。 组件仅在它的 props 发生改变的时候进行重新渲染。通常来说，在组件树中 React 组件，只要有变化就会走一遍渲染流程。但是通过 PureComponent 和 React.memo()，我们可以仅仅让某些组件进行渲染。 PureComponent 要依靠 class 才能使用。而 React.memo() 可以和 functional component 一起使用。 import React from 'react'; const MySnowyComponent = React.memo(function MyComponent(props) { // only renders if props have changed! }); // can also be an es6 arrow function const OtherSnowy = React.memo(props => { return my memoized component; }); // and even shorter with implicit return const ImplicitSnowy = React.memo(props => ( implicit memoized component )); 这种方式依然是一种对象的浅比较，有复杂对象时无法render。在React.memo中可以自定义其比较方法的实现。 function MyComponent(props) { /* render using props */ } function areEqual(prevProps, nextProps) { /* return true if passing nextProps to render would return the same result as passing prevProps to render, otherwise return false */ } export default React.memo(MyComponent, areEqual); 为什么被称为 memo 维基百科：在计算机领域，记忆化是一种主要用来提升计算机程序速度的优化技术方案。它将开销较大的函数调用的返回结果存储起来，当同样的输入再次发生时，则返回缓存好的数据，以此提升运算效率。 这就是 React.memo() 所做的事情，所以叫做 memo 也很说得通。它会检查接下来的渲染是否与前一次的渲染相同，如果两者是一样的，那么就会保留上一次的渲染结果。 错误边界处理 错误边界是用于捕获其子组件树 JavaScript 异常，记录错误并展示一个回退的 UI 的 React 组件，而不是整个组件树的异常。错误边界在渲染期间、生命周期方法内、以及整个组件树构造函数内捕获错误。 错误边界无法捕获： 事件处理 异步代码 服务端渲染 错误边界自身抛出来的错误 一个类组件变成一个错误边界。如果它定义了生命周期方法 static getDerivedStateFromError()或者componentDidCatch()中的任意一个或两个。当一个错误被扔出后，使用static getDerivedStateFromError()渲染一个退路UI。使用componentDidCatch()去记录错误信息。 class ErrorBoundary extends React.Component {ffmpegffmpeg class ErrorBoundary extends React.Component {ffmpegffmpeg constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // Update state so the next render will show the fallback UI. return { hasError: true }; } componentDidCatch(error, info) { // You can also log the error to an error reporting service logErrorToMyService(error, info); } render() { if (this.state.hasError) { // You can render any custom fallback UI return Something went wrong.; } return this.props.children; } } 而后你可以像一个普通的组件一样使用： 事件委托 react 内部帮助我们完成了事件委托，因此我们可以像下面这样绑定事件 {lis.map(li => { return {li.text} })} 错误边界放到哪里 错误边界的粒度是由你决定。你可以将其包装在最顶层的路由组件显示给用户”有东西出错”消息，就像服务端框架经常处理崩溃一样。你也可以将单独的插件包装在错误边界内以保护应用其他部分不崩溃。 相关文章 2018 年，React 将独占前端框架鳌头？ 前端框架三巨头年度走势对比：Vue 增长率最高 React数据流和组件间的沟通总结 单向数据流和双向绑定各有什么优缺点？ 怎么更好的理解虚拟DOM? React中文文档 - 版本较低 React 源码剖析系列 － 不可思议的 react diff 深入浅出React（四）：虚拟DOM Diff算法解析 一看就懂的ReactJs入门教程（精华版） CSS Modules 用法教程 将MarkDown转换为HTML页面 win7命令行 端口占用 查询进程号 杀进程 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/react/React-Component.html":{"url":"notes/react/React-Component.html","title":"React-Component","keywords":"","body":"React-Component Checkbox import React from 'react'; import PropTypes from 'prop-types'; import PureRenderMixin from 'rc-util/lib/PureRenderMixin'; import classNames from 'classnames'; export default class Checkbox extends React.Component { // 定义了 Input 的原生属性 static propTypes = { prefixCls: PropTypes.string, className: PropTypes.string, style: PropTypes.object, name: PropTypes.string, id: PropTypes.string, type: PropTypes.string, defaultChecked: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]), checked: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]), disabled: PropTypes.bool, onFocus: PropTypes.func, onBlur: PropTypes.func, onChange: PropTypes.func, onClick: PropTypes.func, tabIndex: PropTypes.oneOfType([PropTypes.string, PropTypes.number]), readOnly: PropTypes.bool, autoFocus: PropTypes.bool, value: PropTypes.any, }; // 默认属性，即使用户什么都不传，也会存在下列默认属性 static defaultProps = { prefixCls: 'rc-checkbox', className: '', style: {}, type: 'checkbox', defaultChecked: false, onFocus() {}, onBlur() {}, onChange() {}, }; constructor(props) { super(props); const checked = 'checked' in props ? props.checked : props.defaultChecked; this.state = { checked, }; } componentWillReceiveProps(nextProps) { if ('checked' in nextProps) { this.setState({ checked: nextProps.checked, }); } } shouldComponentUpdate(...args) { return PureRenderMixin.shouldComponentUpdate.apply(this, args); } focus() { this.input.focus(); } blur() { this.input.blur(); } // checkbox 的 onchange 事件走的该方法 handleChange = (e) => { // 获取用户传递的 props 属性 const { props } = this; // 判断该 checkbox 是否被禁用 if (props.disabled) { return; } if (!('checked' in props)) { this.setState({ checked: e.target.checked, }); } // 调用用户传递的 onChange 方法，并传递参数 props.onChange({ target: { ...props, checked: e.target.checked, }, stopPropagation() { e.stopPropagation(); }, preventDefault() { e.preventDefault(); }, nativeEvent: e.nativeEvent, }); }; saveInput = (node) => { this.input = node; } render() { const { prefixCls, className, style, name, id, type, disabled, readOnly, tabIndex, onClick, onFocus, onBlur, autoFocus, value, ...others, } = this.props; // 过滤出自定义属性 const globalProps = Object.keys(others).reduce((prev, key) => { if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') { prev[key] = others[key]; } return prev; }, {}); const { checked } = this.state; // 设置 className const classString = classNames(prefixCls, className, { // 该 classname 的添加与否取决于 checked 的值 [`${prefixCls}-checked`]: checked, [`${prefixCls}-disabled`]: disabled, }); return ( ); } } Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/react/React Diff 算法.html":{"url":"notes/react/React Diff 算法.html","title":"React Diff 算法","keywords":"","body":"React Diff 算法 传统的 diff 算法会对两颗树形结构进行遍历，找出其中的差异，找到差异后还要计算最小转换方式，最终达到的算法复杂度是 O(n^3)，其中 n 代表节点个数，1000 个节点就需要 10 忆次比较。 那么 react 是如何做到将 O(n^3) 转变成 O(n) 的呢？ 首先需要了解一下什么是虚拟 DOM ？ 真实的 DOM 树 text 虚拟 DOM 树 { type: 'div', props: { class: 'classname' }, children: [ { type: 'p', props: { value: 'text' } } ] } 可以看到虚拟 DOM 就是将真实的 DOM 转换成了 js 对象，react diff 算法实际上比较的就是两个 js 对象的差异。 那么为什么要采用 js 对象这种操作方式呢？ 传统的 DOM 操作之所以低效，是因为当你在使用 document.createElement('div') 创建一个 div 元素时，会需要按照标准实现一大堆东西，具体实现了什么呢？可以看看下面的代码输出了什么。 const div = document.createElement('div'); for (let key in div) { console.log(key) } 相比之下，js 对象的操作却有着很高的效率。因此 react 才会通过 js 对象的方式构建一颗虚拟 DOM 树。 回到最初的问题：react 是如何做到将 O(n^3) 转变成 O(n) 的呢？ 这里就要讲到 react diff 使用的三个策略： 1、页面中发生跨层级的 DOM 节点移动操作频率很低，可以忽略不计。（tree diff） 2、类型相同的两个组件会产生相似的树形结构，类型不同会产生不同的树形结构。（component diff） 3、对于同一层级的一组子节点，它们可以通过唯一 key 进行区分。（element diff） 策略一：tree diff 页面中发生跨层级的 DOM 节点移动操作频率很低，可以忽略不计。 首先什么是跨层级的 DOM 节点移动操作呢？例如父节点 A 下有 B 和 C 两个子节点，B 和 C 互为兄弟节点。现在将 B 节点移动到 C 节点内，也就是让 B 成为 C 的子节点。这样的操作就称为跨层级的 DOM 节点移动操作。因为本来 B 和 C 属于同一层，现在 B 移动到了另外一层，的确是跨层移动了节点。 由于真实场景中这类操作发生的频率低到可以忽略不计，因此 react 只进行了同层比较。 那么假如发生了跨层移动操作，react 会怎么做呢？ 还是上面的例子，对比第一层，还是 A，没有变化。对比第二层，发现变化，少了 B 节点，因此执行删除操作，删除 B 节点。对比第三层，发现变化，多了 B 节点，因此执行创建操作，创建 B 节点。 可以发现 react 只执行创建和删除操作，并不会出现移动操作，因为 react 无法得知它仅仅只是被移动了。那么这种只创建和删除的操作有什么弊端呢？ 事实上删除操作是很简单的，而麻烦的就是创建操作。试想一下，倘若 B 节点拥有 1000 个子节点，那么创建这样一整个节点树，是非常影响 react 性能的，因此官方并不建议进行 DOM 节点跨层级的操作。 基于这一点，给出以下建议： 1、在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。 2、可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。 策略二：component diff 类型相同的两个组件会产生相似的树形结构，类型不同的会产生不同的树形结构。 这个策略是什么意思呢？ 比如 A 节点下有一个组件类型的节点 B，对比过程中发现 A 下的节点还是组件 B 的话，则按照原策略继续比较虚拟 DOM 树。如果发现 A 下的节点更改为组件 C 的话。这时就会先删除组件 B，再创建组件 C 在 tree diff 中我们知道，这样创建一整个节点树，是会影响 react 性能的。但由于不同类型的组件是很少存在相似 DOM 树的，因此这种极端因素很难在现实开发过程中造成重大影响的。 有时候对于同一类型的组件，虚拟 DOM 可能并没有发生任何变化。如果能够确切知道这点那可以节省大量的 diff 运算时间，因此 react 提供 shouldComponentUpdate 来判断是否需要 diff 策略三：element diff 对于同一层级的一组子节点，它们可以通过唯一 key 进行区分。 这个 key 就是 react 经常报的一个警告，缺少 unique key，在渲染列表时经常遇到。 那 react 让我们加这个 key 的原因是什么呢？ 看一个例子：新老集合所包含的节点如下图所示。当进行差异对比时，发现 B != A，则创建 B 删除 A，同理，创建 A，D，C，删除 B，C，D 可见这种操作冗余繁琐，因为他们都是相同的节点只是位置发生了变化，一些列的删除创建相当低效。 针对这一策略，react 允许开发者对同一层级的同组子节点，添加唯一 key 进行区分。正是这个小小的改动，性能上却发生了翻天覆地的变化！ 如下图所示： 因为有了 key 作唯一标识，在进行 diff 差异化对比时，根据 key 发现都是相同的节点，只是位置不同，因此 react 给出的 diff 结果为 B，D 不作任何操作，A，C 进行移动操作即可。 尽管如此，react diff 还是存在些许不足的的地方。例如老集合为 A，B，C，D，新集合为 D，A，B，C，一眼就可以看出只是 D 的位置发生了变化，我们只需要将 D 移动到最前面即可。但是 react diff 针对这类现象的操作却是将 A，B，C 三个节点移动到 D 的后面。 基于这一点，给出以下建议： 1、在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。 2、因为当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。 参考资料 React 源码剖析系列 － 不可思议的 react diff 谈谈React中Diff算法的策略及实现 传统diff、react优化diff、vue优化diff React源码之Diff算法 react 官方 diff 文档 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/react/React 源码解读.html":{"url":"notes/react/React 源码解读.html","title":"React 源码解读","keywords":"","body":"React 源码分析 创建一个组件 在我们引入 React 时，引入的是源码中提供的 React 对象。这个对象大致长这样： const React = { Component, PureComponent, useState, createElement: __DEV__ ? createElementWithValidation : createElement, .... }; export default React; 通常我们写一个组件大概是这样的： import React from 'react'; class A extends React.Component { constructor() {}, handle() {}, render() { return ( .... ) } }; 我们的组件一般都会继承 React.Component，那么这个 React.Component 里具体干了什么呢？我们可以在源码中找到对应的一个叫 ReactBaseClasser.js 的文件，看看里面写了什么： function Component(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } Component.prototype.isReactComponent = {}; Component.prototype.setState = function(partialState, callback) {}; Component.prototype.forceUpdate = function(callback) {}; 可以很明显的看到，Component 是一个构造函数，定义了自身的属性和方法，其中我们最常用的 setState 方法就定义在了原型上。那么当我们自己的组件 A 继承了 React.Component 后，我们就共享了它身上的属性和方法，所以我们就可以使用其中的 props 属性和 setState 方法。 注意我们在写一个组件时，必须要有 render 方法，且 render 方法必须返回一个类似 DOM 的结构。实际上当我们的组件编写完成后，React 会使用它的 createElement 方法将我们的组件创建为一个 ReactElement 类型的对象，这个 ReactElement 对象打印出来大致是这样的： { // 组件的标识信息 $$typeof: Symbol(react.element), // DOM结构标识，提升update性能 key: null, // 子结构相关信息(有则增加children字段/没有为空)和组件属性(如style) props: {}, // 真实DOM的引用 ref, // _owner === ReactCurrentOwner.current(ReactCurrentOwner.js),值为创建当前组件的对象，默认值为null。 _owner } 这也是我们 console.log(A) 打印一个组件时的样子，这个组件在解析成真实 DOM 之前一直都是 ReactElement 类型的 js 对象。 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/react/React Native.html":{"url":"notes/react/React Native.html","title":"React Native","keywords":"","body":"React Native React Navigation 官网： https://reactnavigation.org/docs/en/getting-started.html Getting started yarn add react-navigation yarn add react-native-gesture-handler react-native link react-native-gesture-handler 修改 MainActivity.java 文件 操作完以上步骤后执行 react-native run-android，项目报错 原因：android 目录下的 settings.gradle 文件中的一行代码 “\\” 使用错误，应修改为 “/” // 错误代码 project(':react-native-gesture-handler').projectDir = new File(rootProject.projectDir, '..\\node_modules\\react-native-gesture-handler\\android') // 正确代码 project(':react-native-gesture-handler').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-gesture-handler/android') 修改完成后再次执行 react-native run-android 命令，依然报错： Execution failed for task ':app:processDebugResources'...等错误信息 百度后知道了需要重新 build，因此我删除了 android/app/ 目录中的 build 文件夹，并重新重新打开 Android Studio 进行 build，在 build 完成后，会重新生成一个 build 文件夹。 之后再次执行 react-native run-android 后，项目成功跑起 Moving between screens 下面这个例子定义了两个 stack 类型的页面， Home 和 Details，这两个组件都在 createStackNavigator 方法中进行注册，页面跳转可以使用 this.props.navigation 对象中的 navigate 或者 push 方法。 至于它们两者的区别可以看例子中的注释 import React from \"react\"; import { View, Text, Button } from \"react-native\"; import { createStackNavigator, createAppContainer } from \"react-navigation\"; // 定义一个 Home 页面 class HomeScreen extends React.Component { render() { return ( Home Screen {/* 点击这个按钮会跳转到 Home 页面 */} this.props.navigation.navigate('Details')} /> ); } } // 定义一个 Details 页面 class DetailsScreen extends React.Component { render() { return ( Details Screen {/* 在 Details 页面中放置了一个按钮，该按钮的作用是点击仍然跳转到 Details 页面，也就是自身。那么在自身跳转到自身会怎么样呢？*/} {/* 如果调用 navigate 方法调转到自身页面，则什么事情都不会发生，因为已经在本页面了 */} {/* 如果调用 push 方法调转到自身页面，则会进行跳转动作，且这个动作会加入到跳转历史里，也就是当点击返回上一页时，会仍然返回该页面 */} this.props.navigation.push('Details')} /> ); } } // createStackNavigator 是一个返回 React 组件的方法，它接收两个参数 // 参数1：route 配置对象 // 参数2：可选的 options 对象 const AppNavigator = createStackNavigator( { Home: HomeScreen, Details: DetailsScreen }, { initialRouteName: \"Home\" } ); const AppContainer = createAppContainer(AppNavigator); export default class App extends React.Component { render() { return ; } } this.props.navigation.goBack() // 返回上一页 this.props.navigation.poptotop() // 返回 stack 中的第一个 Navigation lifecycle 在真实的手机场景中，从页面 A 跳转到页面 B，页面 A 仍然存活并没有销毁，正式这样的机制导致我们按下返回键时会迅速切换回上一页而无需加载。但从 B 返回 A 时，B 被销毁。 在 stack navigator 路由 A 和 B 中，默认首页是 A，进入 A 时，A 的 componentDidMount 将会被触发，在 A 中跳转至 B 时，B 的componentDidMount 触发，但 A 不会触发componentWillUnmount ，当从 B 中返回至 A 时，B 的 componentWillUnmount 被触发，但 A 不会再次触发 componentDidMount 知识点 导航的生命周期 向路由传递参数 传递：this.props.navigation.navigate('RouteName', { / params go here / }) 获取：this.props.navigation.getParam(paramName, defaultValue) 配置页面 Header // 在自己的组件内部添加一个静态对象 navigationOptions class AskScreen extends React.Component { static navigationOptions = { title: '问答', // 标题 headerStyle: { // 头部样式 backgroundColor: '#f4511e', }, headerTintColor: '#fff', // 文字颜色 headerTitleStyle: { // 文字样式 fontWeight: 'bold', }, headerTitle: ， // 该属性值可以是一个组件，现在还不清楚使用规则 headerLeft: , // 左侧按钮 headerRight: , // 右侧按钮 }; } 但为每一个页面单独配置主题色会非常繁琐，因为通常一款 App 的主题色都一致，因此可以配置全局默认的 navigationOptions，在根组件 App.js 中进行配置 import HomeScreen from './src/pages/Home' import AskScreen from './src/pages/Ask' import { createAppContainer, createStackNavigator } from 'react-navigation'; const AppNavigator = createStackNavigator({ Home: { screen: HomeScreen, }, Ask: { screen: AskScreen, }, }, { initialRouteName: 'Home', // 此处配置默认的全局 Header 样式 defaultNavigationOptions: { headerStyle: { backgroundColor: '#f4511e', }, headerTintColor: '#fff', headerTitleStyle: { fontWeight: 'bold', }, }, }); export default createAppContainer(AppNavigator); Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/webpack/webpack 基本使用（一）.html":{"url":"notes/webpack/webpack 基本使用（一）.html","title":"webpack 基本使用（一）","keywords":"","body":"webpack 基本使用（一） 什么是 webpack webpack 主要功能就是分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 可以做的事情： 代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布 npx 是什么 webpack4.0+ 以上推存 0 配置，而且 webpack 也一直朝着这个方向发展。webpack4.0+ 添加了一个 webpack-cli； npx 是一个执行 npm 软件包的二进制文件，通俗的讲，他可以执行 npm 的一些指令，比如 npx webpack 他会执行 node_modules 下面的 bin 下的 webpack.cmd 文件，如果没有安装 webpack 的话，它会自动安装。但是 node 版本不低于 8.6， npm 版本不低于 5.2。 npx 可以通过 npm 下载。 webpack 所说的 0 配置就是与他相关。当然 npx 还有很多功能，你可以移驾到 npm 官网上查看 npx。 webpack 支持 0 配置，默认以 src 目录下的 index.js 做为入口文件。 运行 webpack 运行 webpack 只需要在项目目录下的命令行里敲入 webpack 命令就可以打包，但是该用法需要你全局安装 webpack 才能使用 webpack 命令。 如果不想全局安装 webpack 的话，也可以使用 npx webpack 运行。 执行 npx webpack 执行 npx webpack 会执行 node_modules/bin/webpack.cmd 文件。 文件内容如下：进行了一个判断，判断当前目录下是否有 node.exe @IF EXIST \"%~dp0\\node.exe\" ( \"%~dp0\\node.exe\" \"%~dp0\\..\\webpack\\bin\\webpack.js\" %* ) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node \"%~dp0\\..\\webpack\\bin\\webpack.js\" %* ) webpack 的配置 webpack 是 node 写出来的，所以采用 node 的写法，导出一个对象 webpack 的配置文件名称可以是 webpack.config.js 或者 webpackfile.js，这点可以通过 node_modules/webpack-cli/bin/config/config-yargs.js 文件中看出。 新建一个 webpack.config.js 文件到项目根目录下，内容如下： const path = require('path'); module.exports = { // 打包模式，development 代表开发模式，production 代表生产模式 mode: 'development', // 指向入口文件的路径 entry: './src/index.js', // 输出的配置对象 output: { // 打包后的文件名 filename: 'bundle.js', // 添加 hash 写法 bundle.[hash:8].js // path 的值必须为一个绝对路径，这里使用 path 模块 // path.resolve() 方法可以将当前路径解析为绝对路径，__dirname 指当前路径 path: path.resolve(__dirname, 'dist'), // 指定所有资源的静态路径 publicPath: 'http://xxxx' } } 打包输出的文件分析 打包出来的 bundle.js 是一个自调用函数，传入了一个对象，对象的 key 是模块文件路径，value 就是一个函数。这个对象就是 modules 实参。 // bundle.js (function(modules){})({ './src/index.js': (function() {}) }); 接下来看看函数内部是怎么样的 function(modules) { // 定义了一个对象，保存以及加载过的模块，加载过的就无需第二次加载了 var installedModules = {}; // 实现了一个 require 方法 function __webpack_require__(moduleId) {} // 返回了 require 函数调用，传入了入口文件的路径 return __webpack_require__(__webpack_require__.s = \"./src/index.js\"); } // 总结：该函数内部核心就是实现了一个 require 方法，然后执行了入口文件对应的方法 webpack-dev-server webpack-dev-server 可以帮我们启动一个服务，使用方式非常简单，首先安装它 npm i webpack-dev-server -D 安装完成后执行通过下面的命令运行 npx webpack-dev-server 运行后可以发现就就启动了一服务，这个服务的地址是 http://localhost:8080，访问该地址可以看到项目的目录结构。打开 src 目录就默认打开了 Index.html 文件。 配置 webpack-dev-server module.exports = { // 开发服务器的配置 devServer: { // 配置端口号 port: 3000, // 是否展示进度条 progress: true, // 指定静态服务的目录 contentBase: './src', // 是否开启 gzip 压缩 compress: true } } html-webpack-plugin 插件 该插件可以帮助我们生成一个 html 文件并自动放到 dist 目录当中，且自动帮我们引用打包后的 bundle.js，非常方便，只需要在我们自己的 src 目录下建一个 html 模板即可。 安装 npm i html-webpack-plugin -D 使用 const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { // 配置 plugins 属性，该属性是一个数组，包含所以需要配置的插件 plugins: [ // 创建一个 HtmlWebpackPlugin 实例，并传入配置参数 new HtmlWebpackPlugin({ // 指定模板路径 templete: './src/index.html'， // 打包后的文件名称 filename: 'index.html'， // 添加 hash hash: true })， ] }; loader loader是打包方案，webpack 不能识别非 js 结尾的模块，告知 webpack 某些特定文件如何打包。 loader 的特点，功能单一，这样多个 loader 就可以结合使用了。 loader 的用法： 字符串形式：只能配置一个 loader 数组形式：可以配置多个 loader 数组对象形式：[{}, {}] loader 的执行顺序：默认从右向左，从下到上 打包 css，less 模块 打包 css 模块需要两个 loader，css-loader 和 style-loader，前者帮助我们解析 css 中的 @import 这种语法，后者帮助我们把 css 插入到 head 标签中。 安装 npm i css-loader style-loader -D 配置 module.exports = { // 配置模块参数 module: { // 配置模块对应的规则，它是一个数组，代表可以配置很多规则 rules: [ // 配置一个解析 css 模块的规则 { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] } }; 若要打包 less 模块，只需要多安装 less 和 less-loader，然后在规则中添加一条 Less 的规则 rules: [ // 配置一个解析 less 模块的规则 { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] } ] mini-css-extract-plugin 插件 打包过后的 css 样式默认是插入到 html 文件的 style 标签内的，如果样式很多的话，这个 style 标签中的内容就会很长。这时候我们可以借助一个插件，帮助我们把样式抽离出来，使用 Link 的方式使用。 安装 npm i mini-css-extract-plugin -D 配置 const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { plugins: [ new MiniCssExtractPlugin({ // 设置抽离出来的样式名字 filename: 'main.css' })， ] }; 当我们配置了该插件之后呢，还需要配置该插件的 loader 来替代掉 style-loader rules: [ // 配置一个解析 css 模块的规则 { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] }， // 配置一个解析 less 模块的规则 { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] } ] 为样式添加前缀 比如我们写了一个 transform 属性的样式，我们想让打包后的 css 自动我们添加 webkit 前缀，那么就需要借助一个 autoprefixer 包，但是用这个包又需要借助一个 Loader 来帮我们添加上前缀，就是 postcss-loader 安装 npm i postcss-loader autoprefixer -D 配置 loader，这个前缀我们需要加在 css-loader 之前 rules: [ // 配置一个解析 css 模块的规则 { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] }， // 配置一个解析 less 模块的规则 { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader'] } ] 配置完 Loader 之后还需要添加一个 postcss 的配置文件，告诉它使用 autoprefixer 这个包来添加前缀。 在项目根目录下创建一个 postcss.config.js 文件 // postcss.config.js module.exports = { plugins: [ require('autoprefixer') ] } 压缩打包后的 css 文件 以上步骤打包出来的 css 文件是未经压缩的 css 文件，要想压缩 css 文件需要借助 optimize-css-assets-webpack-plugin 插件 安装 npm i optimize-css-assets-webpack-plugin -D 配置 const OptimizeCss = require('optimize-css-assets-webpack-plugin'); module.exports = { // 优化项 optimization: { minimizer: [ new OptimizeCss() ] } } 配置过后 css 文件就可以被正常压缩了，但这时注意 js 文件不能压缩了，即使你的 mode 是 production 在使用这个压缩 css 的插件时，必须还要使用 uglifyjs-webpack-plugin 插件来让我们的 js 文件依旧压缩 安装 npm i uglifyjs-webpack-plugin -D 配置 const UglifyjsPlugin = require('uglifyjs-webpack-plugin'); const OptimizeCss = require('optimize-css-assets-webpack-plugin'); module.exports = { // 优化项 optimization: { minimizer: [ new UglifyjsPlugin({ // 是否缓存 cache: true, // 是否并发打包 parallel: 4, // 源码映射，方便调试 sourceMap: true }), new OptimizeCss() ] } } 这时候 js 文件又重新的被压缩了 转化 ES6 语法 在我们书写 js 的时候，可能会用到许多 ES6 语法，然而 webpack 处理 ES6 代码还是会原封不动的返回，所以我们需要借助 babel 将我们的 ES6 语法转换为 ES5 安装 npm i babel-loader @babel/core @babel/preset-env -D 配置 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ] } } } ] } } 转化 ES6 class 语法 babel 默认不认识 class 语法，需要借助插件 安装 npm i @babel/plugin-proposal-class-properties -D 配置 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ], plugins: [ '@babel/plugin-proposal-class-properties' ] } } } ] } } 转化 class decorator babel 默认也不认识 class decorator 语法，也需要借助插件 安装 npm i @babel/plugin-proposal-decorators -D 配置 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ], plugins: [ ['@babel/plugin-proposal-decorators', {'legacy': true}], ['@babel/plugin-proposal-class-properties', {'loose': true}], ] } } } ] } } 转化 generator babel 也不认识 generator，需要借助一个运行时的插件 安装 npm i @babel/plugin-transform-runtime -D npm i @babel/runtime -S 配置 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ], plugins: [ ['@babel/plugin-proposal-decorators', {'legacy': true}], ['@babel/plugin-proposal-class-properties', {'loose': true}], '@babel/plugin-transform-runtime' ] } } } ] } } 这时候执行打包可能会出现警告，这是因为我们匹配了所以的 Js 文件，更改以下配置 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ], plugins: [ ['@babel/plugin-proposal-decorators', {'legacy': true}], ['@babel/plugin-proposal-class-properties', {'loose': true}], '@babel/plugin-transform-runtime' ] } }, include: path.resolve(__dirname, 'src'), exclude: /node_modules/ } ] } } 转化 ES7 实例方法 安装 npm i @babel/polyfill -S 在使用到 ES7 实例方法的文件中使用 require('@babel/polyfill') 使用 Eslint 进行代码校验 安装 npm i eslint eslint-loader -D 配置 loader rules: [ { test: /\\.js$/, use: { loader: 'eslint-loader', options: { // 设置该规则在普通 loader 之前执行 enforce: 'pre' } } } ] 配置完成后，可以去 eslint 官网下载一份根据自己需求定制的配置文件 .eslintrc.json，放到根目录 图片处理 项目中图片的使用有三种方式 在 js 中创建图片来引入 在 css 中引入 background: url() img 标签 要让 webpack 可以打包图片则需要 file-loader，它默认会在内部生成一张图片到 dist 目录，并返回图片路径 安装 npm i file-loader -D 配置 rules: [ { test: /\\.(png|jpg|gif|jpeg)$/, use: 'file-loader' } ] 配置完成后在 js 中创建图片可以直接 Import 图片，在 css 中使用直接可以通过相对路径使用，因为 css-loader 帮我们把相对路径更改成了 require 的方式。 但是在 html 文件中通过 img 标签的形式，在 src 中写相对路径时并不生效 这时我们需要借助另一个插件 html-withimg-loader 安装 npm i html-withimg-loader -D 配置 rules: [ { test: /\\.html$/, use: 'html-withimg-loader' } ] 有时我们的图片很小可能只有几 k 的时候，我们可能希望让它不发送请求转换成 base64，利用 url-loader 安装 npm i url-loader -D 配置 rules: [ { test: /\\.(png|jpg|gif|jpeg)$/, use: { loader: 'url-loader', options: { // 限制图片大小界限为 20k，小于该值会转换为 base64 limit: 20*1024, // 将生成的图片放到 img 路径下 outputPath: 'img/', // 为每张图片路径添加公共 path publicPath: 'http://xxx' } } } ] Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/webpack/webpack 基本使用（二）.html":{"url":"notes/webpack/webpack 基本使用（二）.html","title":"webpack 基本使用（二）","keywords":"","body":"webpack 基本使用（二） 打包多页应用 直接上代码 // webpack.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: 'development', // 多页应用对应多入口 entry: { home: './src/home.js', other: './src/other.js' }, output: { // 这里的 name 就是 home 和 other // 这样就会输出 home.js 和 other.js filename: '[name].js', path: path.resolve(__dirname, 'dist') }, plugins: [ // 多页也对应需要 new 多个 HtmlWebpackPlugin 实例 new HtmlWebpackPlugin({ // 各自的模板 templete: './home.html', // 各自输出的名称 filename: 'home.html', // 指定需要引入的 js 文件 chunk: ['home'] }), new HtmlWebpackPlugin({ templete: './other.html', filename: 'other.html', chunk: ['other'] }), ] } 配置 source-map source-map 可以帮我们做源码映射，方便我们调试 配置 module.exports = { devtool: 'source-map' } devtool 属性的值有好几种，不过多记录了。 watch 实时监控 每当我们更改一次代码的时候，都需要重新的去 build 打包，当然你可以用 webpack-dev-server，但是我们也可以让 webpack 进行实时编译 配置 module.exports = { // 开启实时监控 watch: true, // watch 的配置对象 watchOptions: { // 每秒询问 1000 次是否需要重新打包 poll: 1000, // 防抖，防止每一个输入都会重新打包，设置间隔时间 aggregateTimeout: 500, // 不需要监控的文件夹 ignoned: /node_modules/ } } cleanWebpackPlugin 插件 该插件可以帮助我们每次打包的时候删除旧的 dist 目录。 安装 npm i clean-webpack-plugin -D 配置 const CleanWebpackPlugin = require('clean-webpack-plugin'); module.exports = { plugins: [ // 传入要删除的目录路径 new CleanWebpackPlugin('./dist'), ] } copyWebpackPlugin 插件 有时我们想让一些目录直接拷贝进 dist 目录中，例如说明文档目录中的文件，不需要打包只需要拷贝 安装 npm i copy-webpack-plugin -D 配置 const CopyWebpackPlugin = require('copy-webpack-plugin'); module.exports = { plugins: [ // 传入一个对象数组 new CopyWebpackPlugin([ // 意为将 doc 目录中的文件拷贝到 dist 目录中 { from: 'doc', to: './' } ]), ] } bannerPlugin 内置插件 有时我们想让打包后的代码首行生成一段版权注释，使用该 webpack 内置插件 配置 const webpack = require('webpack'); module.exports = { plugins: [ // 传入一个对象数组 new webpack.BannerPlugin('make 2019 by xxx'), ] } 跨域配置 开发过程中经常会遇到跨域问题，那么前端如何解决跨域呢，就是配置代理 配置方式一： module.exports = { devServer: { proxy: { // 以 api 开头的请求都去 3000 端口去找 '/api': 'http://localhost:3000' } } } 配置方式二：有时后端的接口可能并不是固定以 api 开头的 module.exports = { devServer: { proxy: { '/api': { target: 'http://localhost:3000', // 重写 api 置为空 reWrite: { '/api': '' } } } } } resolve 属性 resolve 属性用来解析第三方包 配置 module.exports = { resolve: { // 告诉 webpack 找包去 node_modules 目录下找，当然也可以添加其它目录 modules: [path.resolve('node_modules')], alias: { // 当使用 import 'bootstrap' 时，让它去找 bootstrap/dist/css/bootstrap.css 文件 bootstrap: 'bootstrap/dist/css/bootstrap.css' }， // 引入文件时不写后缀的查找规则，先找 js 再找 css 再找 json entensions: ['.js', '.css', '.json'] } } 定义环境变量 配置 const webpack = require('webpack'); module.exports = { plugins: [ new webpack.DefinePlugin({ // 定义之后，代码中就多了一个 DEV 变量，值为 dev DEV: JSON.striigy('dev') }) ] } 区分不同环境 将开发和生产环境的配置都写到一个文件内会比较难以维护，因此我们可以借助 webpack-merge 将他们分开 首先创建三个文件：webpack.base.js，webpack.dev.js，webpack.prod.js 在 webpack.base.js 文件中，书写开发和生产环境公共的配置 然后再 dev 和 prod 文件中书写各自环境的配置，然后通过插件合并 const { smart } = require('webpack-merge'); const base = require('./webpack.base.js'); module.exports = smart(base, { mode: 'production' }) weback 优化 有时 webpack 的打包速度非常慢，例如当我们使用 jquery 包的时候，webpack 会去检查 jquery 有没有其它依赖项。我们知道 jquery 是没有其它依赖的，那么如何省去这个检查依赖的时间呢？ 配置 module.exports = { module: { noParse: /jquery/, rules: [] } } 还有这样一个场景，我们在使用 moment 这个包的时候，会发先使用它会让我们打包出来 js 文件体积非常大，是因此 moment 这个包就非常大，它里面引入了很多语言的包，因为它支持非常多的语言，那我们只想用中文怎么办？就需要使用 webpack 内置的一个 IgnorePlugin 插件 配置 const webpack = require('webpack'); module.exports = { plugins: [ // 传入的参数意思就是当加载 moment 这个包时，忽略掉引入的 locale 文件 new webpack.IgnorePlugin(/\\.\\/locale/, /moment/) ] } 配置了上面的选项之后，moment 默认就会使用英语作为主语言，那么要想使用中文就需要自己手动引入 happypack 使用多线程打包，加快打包速度 webpack 自带优化 当我们使用 es6 的 import 引入一个文件的时候，可能有一些方法我们是用不到的，那这时候 webpack 通过一种 tree shaking 的方式自动去除掉那些我们引入但没用到的代码在生产模式下。 但是通过 commonjs 的方式引入并没有该优化 webpack 还会自动省略一些可以省略的代码，例如： const a = 1; const b = 2; const c = a + b; console.log(c) 上面的代码 webpack 会通过 scope hosting 作用于提升的方式简化代码，去除不必要的声明，直接打印结果 抽离公共代码 在多页应用中，有很多可以复用的模块，就是那些在多个页面中都有用到的模块，比如页头。这样的公共模块我们可以进行抽取，抽取的好处就是可以被缓存，当一个页面加载过了，下个页面就可以不需要重新加载。 配置 module.exports = { optimization: { // 分割代码块 splitChunks: { // 缓存组 cacheGroups: { common: { // 从入口就开始判断 chunks: 'initial', // 这个模块的大小需要大于 0k minSize: 0, // 这个模块最少需要被引入 2 次 minChunks: 2 }, // 第三方模块也可以抽取 vendor: { // 设置抽取的权重 priority: 1, // 指定包的位置 test: /node_modules/, chunks: 'initial', minSize: 0, minChunks: 2 } } } } } 动态加载模块 有时我们有这样一个需求，当我点击某个按钮的时候，去引入一个 Js 文件，例如 button.onclick = function () { // es6 草案中的语法，实质上使用的是 Jsonp 实现的 import('./source.js').then(data => { console.log(data) }) } 该使用方法默认 webpack 是不支持的，需要借助 @babel/plugin-syntax-dynamic-import 插件 安装 npm i @babel/plugin-syntax-dynamic-import -D 配置 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], // 添加以下配置 plugins: ['@babel/plugin-syntax-dynamic-import'] } } } ] } } vue 懒加载和 react 懒加载都是这样实现的 热更新 使用 webpack-dev-server 时，当我们改动代码的时候浏览器会自动进行刷新，然而我们并不想让它刷新整个页面，我们只想局部刷新，也就是刷新我们改动代码的地方，那就需要使用热更新。 配置 const webpack = require('webpack'); module.exports = { devServer: { // 设置热更新 hot: true }, plugins: [ // 用来告诉是哪个模块更新了的插件 new webpack.NamedModulesPlugin(), // 热更新的插件 new webpack.HotModuleReplacementPlugin() ] } Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/webpack/webpack 深入系列（三）.html":{"url":"notes/webpack/webpack 深入系列（三）.html","title":"webpack 深入系列（三）","keywords":"","body":"webpack 深入系列（三） webpack 深入讲解了 webpack 依赖的 tapable 模块 Tapable webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 Trapable，Tapable 有点类似于 nodejs 中的 events 库，核心原理也是依赖于发布订阅模式。 tapable 中有一些同步和异步的钩子，这些钩子都可以用来绑定函数，执行函数 异步钩子呢又分为串行和并行，串行需要等待前面一个任务执行完。并行是一起执行，等到所有任务执行完成后执行回调函数。 const { Tapable, SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncSeriesHook } = require(\"tapable\"); 假如我们要实现一个功能，这个功能又把它拆分开，分成一个个函数，那按照我们的需求，执行这些函数，可能我们需要它们同步执行，也可能异步执行。tapable 就为我们实现了这样的能力。 SyncHook SyncHook 是一个同步的钩子，会将注册的方法依次执行 需求场景：先学习 node，再学习 react 模拟实现 class SyncHook { // args => ['a', 'b'] constructor(args) { // 保存注册的所有函数 this.tasks = []; } // name 作为标识用 // task 就是注册的函数 tap(name, task) { this.tasks.push(task); } call(...args) { this.tasks.forEach(task => { task(...args); }); } } 使用 // 创建实例 const hook = new SyncHook(); // 注册了两个函数 hook.tap('node', (name) => { console.log('学习 node', name); }) hook.tap('react', (name) => { console.log('学习 react', name); }) // 同步执行注册的所有函数 hook.call('yzn'); 输出 学习 node yzn 学习 react yzn SyncBailHook 同步保险钩子可以让我们在一个同步任务中指定是否继续向下执行。那么如何指定是否继续向下执行呢，就看同步方法中的返回值是不是 undefined，如果不是则不向下继续执行，反之向下继续执行。 需求场景：先学习 node，但是 node 比较难，卡在了 node，无法向下学习 react 了 模拟实现 class SyncBailHook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // 维护一个索引 let index = 0; // 维护函数的返回值 let ret; // 由于至少也会执行第一个函数，因此使用 do while do { // 取出 index 对应的任务，执行并拿到返回值 ret = this.tasks[index++](...args); } // while 中判断是否执行到头且执行的函数返回值是不是 undefined while (index 使用 const hook = new SyncBailHook(); hook.tap('node', (name) => { console.log('学习 node', name); // 这里返回了一个非 undefined 值，因此后面的方法并不会执行了 return '太难了，卡住了' }) hook.tap('react', (name) => { console.log('学习 react', name); }) hook.call('yzn'); 输出 学习 node yzn SyncWaterfallHook 同步瀑布钩子指的是注册的同步函数之间存在关系，比如第二个方法的参数依赖第一个方法的返回值，第三个方法的参数依赖第二个方法的返回值。 需求场景：先学习 node，做了 node 笔记，在学习 react，依然可以查阅 node 笔记 模拟实现 class SyncWaterfallHook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // 解构拿到第一个函数和其它函数 const [first, ...other] = this.tasks; // 执行第一个函数，并拿到返回值 const ret = first(...args); // 利用数组的 reduce 方法，初始值设为 ret other.reduce((prev, next) => { // 这里的 prev 初始是 ret，之后就是每一次 next 调用的返回值了 return next(prev); }, ret); } } 使用 const hook = new SyncWaterfallHook(); hook.tap('node', (name) => { console.log('学习 node', name); return 'node 笔记' }) hook.tap('react', (data) => { console.log('学习 react', data); }) hook.call('yzn'); 输出 学习 node yzn 学习 react node 笔记 SyncLoopHook 同步循环钩子指的是某个同步任务可以循环执行 n 次，那么如何添加这个规则呢？就是在同步函数中添加返回值，如果返回值不是 undefined，那么这个同步函数将被循环执行。 需求场景：先学习 node，由于 node 太难因此需要学习 3 次，学完 3 次后再学习 react 模拟实现 class SyncLoopHook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // forEach 执行每一个任务 this.tasks.forEach(task => { // 内部维护一个 ret 保存函数的返回值 let ret; // 通过 do while 循环执行任务 do { ret = task(...args); } while (ret !== undefined); }); } } 使用 // 维护一个 index，记录执行次数 let index = 0; const hook = new SyncLoopHook(); hook.tap('node', (name) => { console.log('学习 node', name); // 根据 index 的值决定是否返回 undefined return ++index === 3 ? undefined : '继续学习 node'; }) hook.tap('react', (name) => { console.log('学习 react', name); }) hook.call('yzn'); 输出 学习 node yzn 学习 node yzn 学习 node yzn 学习 react yzn AsyncParallelHook 异步并行钩子，特点是注册的异步函数一起执行，当所有异步函数执行完成后会执行一个回调 需求场景：一边学习 node，一边学习 react 模拟实现 class AsyncParallelHook { constructor(args) { this.tasks = []; } tapAsync(name, task) { this.tasks.push(task); } callAsync(...args) { // 维护一个 index，用来计算异步函数的个数 let index = 0; // 拿到最终的 callback 回调函数 const finalCallBack = args.pop(); // 每个异步函数执行完成的回调 // 该 done 的实现类似于 Promise.all 的实现 const done = () => { // 内部自增 Inedx index++; // 并判断 index 与异步函数的个数是否相同，相同则证明执行完成 if (index === this.tasks.length) { // 执行完成则执行最终的回调函数 finalCallBack(); } } this.tasks.forEach(task => { task(...args, done); }) } } 使用 const hook = new AsyncParallelHook(); // 注册异步函数，使用 setTimeout 模拟 hook.tapAsync('node', (name, cb) => { setTimeout(() => { console.log('学习 node', name); // 异步执行完成后需要手动执行 cb 函数，这个 cb 就是 done 函数 cb(); }, 1000); }) hook.tapAsync('react', (name, cb) => { setTimeout(() => { console.log('学习 react', name); cb(); }, 1000); }) // call 所有异步函数，并传入一个回调 // 这个回调就是所有异步函数执行完成后需要执行的回调 hook.callAsync('yzn', () => { console.log('学习完成'); }); 输出 学习 node yzn // 一秒后打印 学习 react yzn // 两秒后打印 学习完成 // 异步函数都执行完成后打印 上面的方式注册的异步函数是一个普通函数，AsyncParallelHook 还可以注册 Promise 函数 模拟实现 class AsyncParallelHook { constructor(args) { this.tasks = []; } tapPromise(name, task) { this.tasks.push(task); } promise(...args) { // 这里使用 map 获取 promise 数组 let tasks = this.tasks.map(task => task(...args)); // 使用 Promise.all 执行 promise 数组，返回最终结果的 Promise return Promise.all(tasks); } } 使用 const hook = new AsyncParallelHook(); // 注册异步函数，使用 Promise hook.tapPromise('node', (name) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('学习 node', name); // 执行完成后 resolve resolve(); }, 1000); }) }) hook.tapPromise('react', (name) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('学习 react', name); resolve(); }, 2000); }) }) // 使用 then 替代回调函数 hook.promise('yzn', ).then(() => { console.log('学习完成'); }); 输出 学习 node yzn // 一秒后打印 学习 react yzn // 两秒后打印 学习完成 // 异步函数都执行完成后打印 AsyncSeriesHook 异步串行钩子，特点是注册的异步函数一个一个执行 需求场景：先学习 node，再学习 react（异步） 模拟实现 class AsyncSeriesHook { constructor(args) { this.tasks = []; } tapAsync(name, task) { this.tasks.push(task); } callAsync(...args) { // 取出最终的回调函数，在参数最后一位 const finalCallBack = args.pop(); // 维护一个索引 let index = 0; // 定义一个 next 方法 const next = () => { // 判断递归的终点 if (this.tasks.length === index) { // 调用最终回调函数 return finalCallBack(); } // 执行每一次的任务，next 作为 callback this.tasks[index++](...args, next); }; next(); } } 使用 const hook = new AsyncSeriesHook(); hook.tapAsync(\"node\", (name, cb) => { // setTimeout 模拟异步 setTimeout(() => { console.log(\"学习 node\", name); // 任务完成后手动调用 cb，这里的 cb 就是 next 函数 cb(); }, 1000); }); hook.tapAsync(\"react\", (name, cb) => { setTimeout(() => { console.log(\"学习 react\", name); cb(); }, 2000); }); hook.callAsync(\"yzn\", () => { console.log(\"学习完成\"); }); 输出 学习 node yzn // 一秒后打印 学习 react yzn // 两秒后打印 学习完成 // 异步函数都执行完成后打印 使用 Promise 模拟实现 class AsyncSeriesHook { constructor(args) { this.tasks = []; } tapPromise(name, task) { this.tasks.push(task); } promise(...args) { const [first, ...others] = this.tasks; return others.reduce((promise, next) => { return promise.then(() => next(...args)); }, first(...args)); } } 使用 const hook = new AsyncSeriesHook(); hook.tapPromise(\"node\", name => { return new Promise((resolve, reject) => { setTimeout(() => { console.log(\"学习 node\", name); resolve(); }, 1000); }); }); hook.tapPromise(\"react\", name => { return new Promise((resolve, reject) => { setTimeout(() => { console.log(\"学习 react\", name); resolve(); }, 1000); }); }); hook.promise(\"yzn\").then(() => { console.log(\"学习完成\"); }); Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/Applet.html":{"url":"notes/Applet.html","title":"Applet","keywords":"","body":"Applet Page：用page()注册一个页面 data：页面初始数据 onLoad：监听加载 onReady：监听初次渲染完成->调用一次，可以和视图层进行交互 onShow：监听页面显示->调用一次 onHide：监听页面隐藏 onUnload：监听页面卸载->close页面 onPageScroll：页面滚动触发事件的处理函数 加载顺序：onLoad->onShow->onReady->onHide->onShow->onUnload 页面第一次启动加载顺序：onLaunch->onLoad->onShow->onReady->onHide->onShow->onUnload 页面隐藏后启动加载顺序：onHide->onLoad->onShow->onReady->onHide->onShow->onUnload Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/Docker.html":{"url":"notes/Docker.html","title":"Docker","keywords":"","body":"Docker 安装 这里记录一下在低版本 windows 系统中的安装过程。 步骤一：下载 docker toolbox 下载地址：https://get.daocloud.io/toolbox/ 步骤二：安装 在 select components 安装页面中，勾选需要的组件，由于我电脑装好了 Git 因此没有勾选 Git 组件。 正因为我没有勾选 Git，让我在安装完成后运行 Docker Quickstart Terminal 时遇到了第一个问题。 步骤三：运行 运行安装完成后桌面上的 Docker Quickstart Terminal 快捷方式。 出现第一个问题：windows 正在查找 bash.exe ？ 解决：由于没有勾选 Git，所以它无法找到 Git 的 bash.exe 在哪，所以这时候需要手动指定该位置。右键 Docker Quickstart Terminal 选择属性，在目标处修改自己安装的 bash.exe 位置。 再次运行出现第二个问题：No default Boot2Docker ISO found locally, downloading the latest release ？ 解决：由于启动时没有检测到 Boot2Docker，因此它会去下载，下载地址通常会显示在命令行当中。它其实是 github 上的 boot2docker 库。去 github 上手动下载下来并放在 c/user/username/.docker/machine/cache 下即可。下载速度很慢可以使用迅雷下载。 至此可以正常启动 Docker Quickstart Terminal 步骤四：配置国内镜像源 阿里云镜像：https://gctn5mcm.mirror.aliyuncs.com 如果已经创建了 Docker Machine 实例，可以这样配置： # 第一步 docker-machine ssh default # 第二步 sudo sed -i \"s|EXTRA_ARGS='|EXTRA_ARGS='--registry-mirror=https://gctn5mcm.mirror.aliyuncs.com |g\" /var/lib/boot2docker/profile # 第三步 exit # 第四步 docker-machine restart default 如果没有创建 Docker Machine 实例，可以这样配置： # 创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址。 docker-machine create --engine-registry-mirror=加速地址 -d virtualbox default # 查看机器的环境配置，并配置到本地，并通过Docker客户端访问Docker服务。 docker-machine env default eval \"$(docker-machine env default)\" docker info docker info 命令可以用来查看一些信息，其中的 registry 就是加速地址。 在 ubuntu 18.04 中安装 Docker 参考：https://www.yuque.com/grasilife/docker/install-ubuntu 配置镜像加速器：https://www.yuque.com/grasilife/docker/install-mirror 常用命令 # 查看本地仓库的所有镜像 docker images docker images -a # 查看所有在运行的容器信息 docker ps # 查看所有容器信息，包括未运行的 docker ps -a # 创建并运行一个新的容器 docker run -p 8080:80 --name myNginx -d nginx # 启动一个或多个已经被停止的容器 docker start 容器名/容器 ID 容器名/容器 ID # 停止一个运行中的容器 docker stop 容器名/容器 ID # 重启容器 docker restart 容器名/容器 ID # 强制删除一个或多个容器 docker rm -f 容器名/容器 ID 容器名/容器 ID # 从容器创建一个新的对象 docker commit -a '作者' -c(使用 DockerFile) -m 'commit 说明' -p(提交时暂停容器) 删除镜像（image） docker rmi {仓库}:{标签名} docker rmi {镜像 ID} 查看卷 docker volume ls 删除卷 docker volume rm {卷名} Docker 安装 Tomcat 安装启动 # 步骤一：拉取 tomcat 镜像 docker pull tomcat # 步骤二：启动该 tomcat 镜像 docker run -d -p 8080:8080 镜像ID # 步骤三：打开浏览器访问 localhost:8080 # 问题：在我打开 localhost:8080 时看到 404 页面，并没有看到 tomcat 启动成功的页面 # 原因：在启动的 tomcat 容器中，webapps 下没有 ROOT 文件夹 # 解决：利用 docker exec -it 容器ID /bin/bash 进入容器，并在 webapps 下新建 ROOT 目录 挂载数据卷 # 将宿主机下的 /home/yzn/test/webapps 目录映射到容器内的 /usr/local/tomcat/webapps 目录 # 这样的好处是每次修改宿主机下的文件即可自动映射到容器内部，且不需要重新启动容器。 docker run -d -p 8080:8080 -v /home/yzn/test/webapps:/usr/local/tomcat/webapps 镜像ID Docker 安装 Nginx # 步骤一：拉取镜像 docker pull nginx # 步骤二：启动该镜像 docker run -d -p 8080:80 镜像ID # 步骤三：打开浏览器访问 localhost:8080 挂载数据卷 # /usr/share/nginx/html/index.html 默认的启动页面 # /etc/nginx/nginx.conf 配置文件位置 # /var/log/nginx 日志文件位置 # 例：挂载宿主机 index.html 到容器内并启动 docker run -d -p 8080:8080 -v /home/yzn/test/nginx/index.html:/usr/share/nginx/html/index.html 镜像ID Docker 安装 Mysql # 步骤一：拉取镜像 docker pull mysql # 步骤二：启动该镜像，-e MYSQL_ROOT_PASSWORD=123456 为设置环境变量，这里是设置登陆 mysql 的密码，不设置将无法启动成功 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 镜像ID # 步骤三：进入容器内部 docker exec -it 容器ID bash # 步骤四：在容器内登陆 mysql mysql -u root -p # 步骤五：查看用户信息 # host 字段代表可以访问当前用户的主机地址，其中 localhost 仅本地能访问。设为 % 则全部都能访问。 # plugin 字段表示设置加密的插件。mysql 8 之前的版本均使用 mysql_native_password 插件，8 之后统一改成了 caching_sha2_password 插件，插件的差异会影响 navicat 连接报错 # 备注：host为 % 表示不限制ip localhost表示本机使用 plugin 非 mysql_native_password 则需要修改密码 select host,user,plugin,authentication_string from mysql.user; # 步骤六：设置用户。这里设置 root 用户不限制 IP，且插件改为 mysql_native_password，并重新设置了密码。 ALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; # 步骤七：刷新。之后便可以在本地使用 navicat 连接 docker 容器内的 mysql 了 FLUSH PRIVILEGES; 安装文件位置 # 配置文件 /etc/mysql/my.cnf # 数据库文件存放的地方 /var/lib/mysql # 日志 /var/log/mysql 配置文件样例 # Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved. # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; version 2 of the License. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # # You should have received a copy of the GNU General Public License # along with this program; if not, write to the Free Software # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA # # The MySQL Server configuration file. # # For explanations see # http://dev.mysql.com/doc/mysql/en/server-system-variables.html [mysqld] pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql secure-file-priv= NULL # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 # Custom config should go here !includedir /etc/mysql/conf.d/ default_authentication_plugin= mysql_native_password Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2020-03-19 16:04:23 "},"notes/Fetch.html":{"url":"notes/Fetch.html","title":"Fetch","keywords":"","body":"Fetch 参考资料 https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch [Fetch API 初探] http://coderlt.coding.me/2016/11/20/JS-Feach/ fetch() fetch(url,{ // url: 请求地址 method: \"GET\", // 请求的方法POST/GET等 headers : { // 请求头（可以是Headers对象，也可是JSON对象） 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: , // 请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get或head方法中不能包含body） cache : 'default', // 是否缓存这个请求 credentials : 'same-origin', //要不要携带 cookie 默认不携带 omit、same-origin 或者 include mode : \"\", /* mode,给请求定义一个模式确保请求有效 same-origin:只在请求同域中资源时成功，其他请求将被拒绝（同源策略） cors : 允许请求同域及返回CORS响应头的域中的资源，通常用作跨域请求来从第三方提供的API获取数据 cors-with-forced-preflight:在发出实际请求前执行preflight检查 no-cors : 目前不起作用（默认） */ }).then(resp => { /* Response 实现了 Body, 可以使用 Body 的 属性和方法: resp.type // 包含Response的类型 (例如, basic, cors). resp.url // 包含Response的URL. resp.status // 状态码 resp.ok // 表示 Response 的成功还是失败 resp.headers // 包含此Response所关联的 Headers 对象 可以使用 resp.clone() // 创建一个Response对象的克隆 resp.arrayBuffer() // 返回一个被解析为 ArrayBuffer 格式的promise对象 resp.blob() // 返回一个被解析为 Blob 格式的promise对象 resp.formData() // 返回一个被解析为 FormData 格式的promise对象 resp.json() // 返回一个被解析为 Json 格式的promise对象 resp.text() // 返回一个被解析为 Text 格式的promise对象 */ if(resp.status === 200) return resp.json(); // 注： 这里的 resp.json() 返回值不是 js对象，通过 then 后才会得到 js 对象 throw New Error ('false of json'); }).then(json => { console.log(json); }).catch(error => { consolr.log(error); }) 获取数据 我们使用 github 为开发者提供的 url，我们可以像这样获取数据 fetch('https://api.github.com/users/chriscoyier/repos'); Fetch会返回Promise，所以在获取资源后，可以使用.then方法做你想做的。 fetch('https://api.github.com/users/chriscoyier/repos') .then(response => {/* do something */}) 然而打印这个 response，会得到以下信息 { // 一个简单的getter用于暴露一个 ReadableStream 类型的 body 内容。 body: ReadableStream, // 包含了一个布尔值来标示该 Response 是否读取过 Body. bodyUsed: false, // 包含此 Response 所关联的 Headers 对象. headers: Headers, // 包含了一个布尔值来标示该 Response 成功（状态码的范围在200-299） ok : true, redirected : false, // 包含 Response 的状态码 （例如 200 表示成功） status : 200, // 包含了与该 Response 状态码一致的状态信息 (例如, OK对应 200). statusText : \"OK\", // 包含 Response 的类型 (例如, basic, cors). type : \"cors\", // 包含 Response 的 URL. url : \"http://some-website.com/some-url\", __proto__ : Response } 知识点： 我们想要的 json 信息都存储在 body 中，作为一种可读的流，需要一个恰当方法将可读流转换为可用数据 Github返回的响应是JSON格式的，所以调用response.json方法来转换数据 还有其他方法来处理不同类型的响应。如果请求一个XML格式文件，则调用response.text。如果请求图片，使用response.blob方法。 fetch('https://api.github.com/users/chriscoyier/repos') .then(response => response.json()) .then(data => { // data就是我们请求的 json 数据 console.log(data) }); Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/Java.html":{"url":"notes/Java.html","title":"Java","keywords":"","body":"Java 环境变量的配置 类 类中的属性必须被封装，访问和设置属性通过相应的 set 和 get 方法 一个类中可以拥有至少一个构造函数 构造函数的名称必须与类名一致 构造函数中可以通过 this() 的方式调用其它构造函数，以参数来区分调用的是哪个构造函数 this() 必须写在首行 构造函数可以被私有化，也就是使用 private 修饰，被私有化构造函数的类无法在外部使用 new 实例对象 当 new 出一个类的实例对象时，根据传入的参数不同指定执行哪一个构造函数 当 new 出一个类的实例对象时，如果没有使用变量接收，则创建出来的对象称为匿名对象 class Person { private String name; private int age; public Person() { System.out.print(\"无参构造函数\"); } public Person(String name, int age) { this(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String n) { name = n; } public int getAge() { return age; } public void setAge(int a) { age = a; } public void sayName() { System.out.print(\"姓名：\" + name + \" 年龄：\" + age); } } 继承 子类中可以利用 super() 调用父类的构造函数 子类允许覆写父类的属性和方法，但需要注意权限 子类覆写的方法不能拥有比父类方法更加严格的访问权限，即 子类中方法权限应 > 父类中方法权限 从 private 变为 default 不算方法覆写 public class HelloWorld { public static void main(String args[]) { Student stu = new Student(\"yzn\", 18, \"清华\"); stu.sayInfo(); stu.sayName(); } } class Person { private String name; private int age; public Person() { System.out.println(\"无参构造函数\"); } public Person(String name, int age) { this(); this.name = name; this.age = age; System.out.println(\"有参构造函数\"); } public String getName() { return name; } public void setName(String n) { name = n; } public int getAge() { return age; } public void setAge(int a) { age = a; } public void sayName() { System.out.println(\"姓名：\" + name); } } class Student extends Person { String school; public Student(String name, int age, String school) { super(name, age); this.school = school; } public void sayInfo() { System.out.println(\"姓名：\" + this.getName() + \" 年龄：\" + this.getAge() + \" 学校：\" + school); } } 代码块 代码块是指用 {} 括起来的一段代码，根据位置不同，代码块分为普通、构造、静态和同步四中代码块 下面的代码在创建 new 出一个实例对象时，输出的结果先后顺序为：静态代码块 > 构造块 > 构造方法 且静态代码块先于主方法执行 class Demo { { System.out.println('构造块') } static { System.out.println('静态代码块') } public Demo() { System.out.println('构造方法') } } static 使用 static 声明属性 使用 static 关键字描述的属性被称为全局属性，也称为静态属性。 // Person 类中有一个 City 属性，被 static 修饰，则该属性就是一个全局属性 // 也就是每一个 Person 实例的值都是 A 城，当其中一个实例修改了这个属性，则所有实例的该属性均被修改了 class Person { static String city = 'A 城' } 使用 static 声明方法 使用 static 声明从方法被称为类方法 // 使用 static 修饰的方法可以使用类名调用：Person.setCity() // 非 static 声明的方法中可以去调用 static 声明的方法或者属性，但反之不行 class Person { static String city = 'A 城' public static void setCity(String c) { city = c } } final 使用 final 声明的类不能有子类 使用 final 声明的方法不能被子类覆写 使用 final 声明的变量即为常量，常量不可以被修改 内部类 如果在类 Outer 的内部再定义一个类 Inner，此时 Inner 就称为内部类，而 Outer 就称为外部类 内部类的唯一好处就是可以方便的访问外部类中的私有属性 使用 static 声明的内部类不能访问非 static 的外部类属性 在外部访问内部类 Outer out = new Outer() Outer.Inner in = out.new Inner() 在方法中也可以定义内部类 抽象类 在 Java 中，可以创建一个类专门用来当作父类，这种类称为抽象类。抽象类的作用类似于“模板”，其目的是要设计者根据它的格式来修改并创建新类。但是并不能直接由抽象类创建对象，只能由抽象类派生出新的类，再由这个新的类来创建对象。 抽象类的定义与使用规则： 包含一个抽象方法的类必须是抽象类 抽象类和抽象方法都要使用 abstract 关键字声明 抽象方法只需要声明而不需要实现 抽象类必须被子继承，子类（如果不是抽象类）则必须覆写抽象类中的全部抽象方法 abstract class A { public A() { System.out.println('A 抽象类构造方法') } } class B extends A { public B() { System.out.println('B 子类构造方法') } } public class Demo { public static void main(String args[]) { B b = new B() } } 输出：A 抽象类构造方法 > B 子类构造方法 之所以调用了 A 类中的无参构造方法，是因为再 B 的无参构造方法中隐含了 super() 语句 接口 接口是一种特殊的类，由全局常量和公共的抽象方法组成 // 接口定义格式 interface 接口名称 { 全局常量 ; 抽象方法 ; } 注意： 接口中的抽象方法必须定义为 public 访问权限，这是绝对不可改变的 在接口中如果不写 public 则也是 public 访问权限，并不是 default 与抽象类一样，接口若要使用也必须通过子类，子类通过 implements 关键字实现接口 // 实现接口格式，注意：子类可实现多个接口 class 子类 implements 接口A, 接口B, ... { } 如果一个子类既要实现接口又要继承抽象类呢？ // 子类既实现接口又继承抽象类 class 子类 extends 抽象类 implements 接口A, 接口B, ... { } 对象的多态性 多态在 java 中有两种体现：方法的重载和覆写以及对象的多态性 对象的多态性主要分为以下两种： 向上转型：子类对象 => 父类对象 向下转型：父类对象 => 子类对象 泛型 有时候当定义一个类时，类中属性的类型可能是不确定的，这时候可以使用泛型，由外部指定类型 public class Demo { public static void main(String args[]) { // 指定 x 属性为 String 类型 Info i = new Info(\"北纬20°\")； // 指定 x 属性为整型 Info i = new Info(20) } } class Info { private T x; public Info(T x) { this.x = x; } public T getX() { return x; } public setX(T x) { this.x = x; } } Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/Mongodb.html":{"url":"notes/Mongodb.html","title":"Mongodb","keywords":"","body":"mongodb 启动数据库 可以使用以下命令检查是否安装成功 mongod --version // 如果不可用 检查是否配置环境变量 目录为 mongodb 安装目录的 bin 目录下 启动： # mongodb默认使用执行 mongod 命令所处盘符根目录下的 /data/db 作为自己的数据存储目录 mongod # 所以第一次执行该命令之前先自己手动新建一个 /data/db 如果想要修改默认的数据存储目录，可以： mongod -- dbpath=数据存储目录路径 停止： 在开启服务的控制台，直接 Ctrl+c 即可停止 连接数据库 连接：（连接数据库之前需保证数据库启动） # mongo 命令默认连接本机的 MongoDB 服务 mongo 退出： # 在连接状态输入 exit 退出链接 exit 基本命令 show dbs 查看显示所有数据库 db 查看当前操作的数据库 use 数据库名称 切换到指定的数据库（如果没有会新建） show collections 展示当前数据库下的所有集合（表） 查询操作 db.user.insert({'name': 'yzn', 'age': 20}) 往 user 表中插入一条数据 db.user.find() 查询 user 表中所有数据 db.user.find({'age': 20, 'name': 'yzn'}) 查询 user 表中 age = 20 name = yzn 的数据 db.user.find({'age': { $gt: 20 }}) 查询 uese 表中 age 大于 20 的数据 db.user.find({'age': { $gte: 20 }}) 查询 user 表中 age 大于等于 20 的数据 db.user.find( {'age': { $gte: 20, $lte: 30 }} ) 查询 user 表中 age 大于等于 20 且 小于等于 30 的数据 模糊查询 db.user.find({\"name\": /张/}) 查询 user 表中 name 包含 张 的数据 db.user.find({\"name\": /^张/}) 查询 user 表中 name 以 张 开头数据 列查询 db.user.find( {}, {age, 1} ) // 第一个参数为空对象, age 可以不加引号，值为 1 查询 user 表中 age 列的所有数据 db.user.find( {'age': { $gt: 20 }}, {name: 1} ) 查询 age大于 20 的所有数据的 name 列数据 db.user.find( {}, { age: 1, name: 1 } ) 查询 age 和 name 两列数据 查询并排序 db.user.find().sort( {'age': 1} ) // -1 为降序 查询 user 表中的所有数据，并按照 age 升序排列 查询前 n 条数据 db.user.find().limit(5) 查询 user 表中的前 5 条数据 查询 n 条数据以后的 m 条数据 db.user.find().skip(2).limit(3) 查询 user 表中前 2 条后的 3 条数据 or 查询 db.user.find( { $or: [ {\"age\": 20}, {\"age\": 24} ] } ) 查询 user 表中 age 等于 20 或 24 的数据 查询第一条数据 db.user.findOne() 查询 user 表中的第一条数据 db.user.find().limit(1) 查询 user 表中的第一条数据 查询数量 db.user.find().count() 查询 user 表中所有数据的数量 db.user.find({ 'age': 20 }).count() 查询 user 表中 age 等于 20 的数据的数量 删除操作 db.user.remove({ 'age': 20 }) 删除 user 表中所有 age 为 20 的数据 db.user.remove({'age': 20}, {justOne: true}) 删除 user 表中 age 为 20 的第一条数据 删除数据库 db.dropDatabase() 删除 数据库 删除集合 db.user.drop() 删除 user 集合 修改操作 注：不写 $set 的话默认将一整条数据修改成第二个参数的数据 db.user.update( {'name': 'wangwu'}, {$set: { 'age': 60 }} ) 将 name 等于 wangwu 的数据的 age改为 60 索引 索引是对数据库表中一列或多列的值进行排序的一种结构，可以让我们查询数据库变得 更快。MongoDB 的索引几乎与传统的关系型数据库一模一样，这其中也包括一些基本的查 询优化技巧。 创建索引 ​ db.user.ensureIndex({\"username\":1}) 获取当前集合的索引 ​ db.user.getIndexes() 删除索引 ​ db.user.dropIndex({\"username\":1}) 创建复合索引 ​ 数字1 表示username 键的索引按升序存储，-1 表示age 键的索引按照降序方式存储。 ​ db.user.ensureIndex({\"username\":1, \"age\":-1}) 唯一索引 ​ db.user.ensureIndex({\"userid\":1},{\"unique\":true}) ​ 如果再次插入userid 重复的文档时，MongoDB 将报错，以提示插入重复键 在 Node 中操作 MongoDB 数据库 使用官方的 mongodb 包来操作（比较原生） https://github.com/mongodb/node-mongodb-native 使用第三方 mongoose 来操作 MongoDB 数据库（推荐），它基于 mongodb 官网的 mongodb 包再一次做了封装 mongoose 官网：http://mongoosejs.com/ 官方指南：http://mongoosejs.com/docs/guide.html 官方API文档：http://mongoosejs.com/docs/api.html 1. MongoDB 数据库的基本概念 数据库 集合（数据表） 文档（表结构） 可以有多个数据库 一个数据库中可以有多个集合（表） 一个集合中可以有多个文档（表记录） 文档结构很灵活，没有任何限制 MongoDB 非常灵活，不需要像 MySQL 一样先创建数据库、表、设计表结构 在这里只需要：当你需要插入数据的时候，只需要指定往哪个数据库哪个集合操作就可以了 一切都是由 MongoDB来帮你自动完成建库建表这件事儿 { // qq 和 taobao 是数据库，users 和 goods 是集合，[] 中的 {} 是文档 qq:{ users:[ {name: '张三', age: 15}，{} ], goods:[ {}，{} ], }, taobao:{ } } 2. 起步 安装： npm i mongoose -S //在需要安装的文件目录下执行该命令 hello world： const mongoose = require('mongoose'); mongoose.connect('mongodb://localhost/test'); const Cat = mongoose.model('Cat', { name: String }); const kitty = new Cat({ name: 'Zildjian' }); kitty.save().then(() => console.log('meow')); 3. 官方指南 3.1 设计 Schema 发布 Model // 引入mongoose const mongoose = require('mongoose'); // 对于Mongoose，一切都源自一个模式 const Schema = mongoose.Schema ; // 1 - 链接数据库 // 指定的数据库不需要存在，当你插入第一条数据后就自动创建了 mongoose.connect('mongodb://localhost/test'); // 2 - 设计集合结构（表结构） // 字段名称就是表结构中的属性名称 // 值：约束的目的是为了保证数据的完整性，不要有脏数据 var userSchema = new Schema({ username:{ type:String, required:true // 非空 }, password:{ type:String, required:true }, email:{ type:String } }); // 3 - 将文档结构发布为模型 // mongoose.model 方法就是用来将一个架构发布为 model // 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称， // mongoose会自动将大写的字符串生成小写复数的集合名称 例：User -> users // 第二个参数：架构 Schema // 返回值：模型构造函数 var User = mongoose.model('User',userSchema); // 4 - 当我们有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据为所欲为 3.2 增加数据 // 增加数据 var admin = new User({ username:'admin', password:'123456', email:'admin@admin.com' }); // 保存数据 admin.save(function(err,result){ if(err){ console.log('保存失败') }else{ console.log('保存成功') console.log(result) // result 就是插入的这条数据 } }) 3.3 查询数据 // 查询所有数据 User.find(function(err,result){ if(err){ console.log('查询失败') }else{ console.log(result) // result 为一个数组，数组内为查询结果 } }) // 按条件查询数据 // 传入第一个参数 - 对象 对象内为条件 User.find({ username:'zs' },function(err,result){ if(err){ console.log('查询失败') }else{ console.log(result) // result 为一个数组，数组内为查询结果 } }) // 按照条件查询单个数据 // 如果没有传入条件 findOne默认查询第一条数据 User.findOne({ username:'zs', password:'123456' },function(err,result){ if(err){ console.log('查询失败') }else{ console.log(result) // result 为当前的数据对象 } }) 3.4 删除数据 根据条件删除所有： // 删除数据 // 此例表示删除所有 username 为 zs 的数据 User.remove({ username:'zs' },function(err,result){ if(err){ console.log('删除失败') }else{ console.log('删除成功') console.log(result) } }) 根据条件删除一个： Model.findOneAndRemove(conditions, [options], [callback]) 根据 id 删除一个： Model.findByIdAndRemove(id, [options], [callback]) 3.5 更新数据 根据 id 更新一个： // 更新数据 // 第一个参数为id的值，第二个参数为修改的内容 User.findByIdAndUpdate('5a001b235',{ password:'111111' },function(err,result){ if(err){ console.log('更新失败') }else{ console.log('更新成功') } }) 根据条件更新所有： Model.update(conditions, doc, [options], [callback]) 根据条件删除一个： Model.findOneAndUpdate([conditions], [update], [options], [callback]) Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/OpenLayers.html":{"url":"notes/OpenLayers.html","title":"OpenLayers","keywords":"","body":"OpenLayers example 网格背景 几何元素拖动 拖拽修改几何元素 绘制几何元素 涂鸦绘制几何元素 绘制几何形状 点对点行走动画 网格地图分划覆盖 为线绘制箭头 Moveend Event Mouse Position 多边形样式 Snap 交互绘制修改几何元素 选区 Overlay 修改几何元素测试 Popup Vector labels ol.Map const map = new Map({ layers: [], target, view }); 给地图绑定事件： // 绑定地图事件，singleclick，dblclick，contextmenu、pointermove map.on('singleclick', (e) => { }); // moveend 事件，当地图 zoom 改变时触发 map.on('moveend', (e) => { // 该事件存在 bug，就是当拖动地图停下的时候也会触发事件 }); // 为了防止 moveend 事件的 bug，可以使用下面的方式 map.getView().on('change:resolution', e => { console.log(e.target.getZoom()); }); ol.layer.Vector brightness，亮度，默认为 0 ； contrast，对比度，默认为 1 ； hue，色调，默认为0 ； opacity，透明度，默认为 1 ，即完全透明； saturation，饱和度，默认为 1 ； source，图层的来源，如果在构造函数中没有传入相应的参数，可以调用 ol.layer.Layer#setSource方法来设置来源： layer.setSource(source) ； visible，是否可见，默认为 true ； extent，图层渲染的区域，即浏览器窗口中可见的地图区域。extent 是一个矩形范围，格式是[number, number, number, number] 分别代表 [left, bottom, right, top] 。如果没有设置该参数，图层就不会显示； minResolution，图层可见的最小分辨率，当图层的缩放级别小于这个分辨率时，图层就会隐藏； maxResolution，图层可见的最大分辨率，当图层的缩放级别等于或超过这个分辨率时，图层就会隐藏。 ol.interation.Draw 绘图控件对象 const draw = new Draw({ // 绘制层的数据源 source: source, // 绘制的元素类型 type: 'circle', // 默认的绘制类型只有四种类型，如果我想绘制一个矩形框呢？当然有一个拉框交互可以实现这个效果，这里我们使用 draw 交互来实现拉框的效果，这个要结合 maxPoints 加以限制。 geometryFunction: geometryFunction, // 数值类型，单位是像素，判断用户鼠标（PC）或者手指（移动设备）的行为是添加点，还是按住鼠标或者手指不松开进行拖拽地图，默认值是 6 像素，也就是说当按下鼠标和抬起鼠标左键之间的这段时间段内，如果地图被拖动没有超过 6 像素，那么默认为添加一个点，相反如果超过了 6 像素，那么不会添加点，只是平移一下地图。 clickTolerance, // 绘制的要素所属的要素集合，要素集合（featureCollection）是要素集（source）的一个子集，要素集包含要素集合。要素集合添加到要素集（source），才会显示到 source 所属的矢量图层。这个参数和 source 参数很类似。 features, // 数值，像素为单位，默认值是 12 像素。上面我们提到完成多边形时，可以把最后一个点与第一个点重合来完成，那么我们知道重合很难做到，只有吸附才能做到精确重合。上图可以看到鼠标所指的位置和吸附的矢量点还有一定的距离，也就是说当鼠标位置进入以矢量点为圆心，一定距离为半径的圆范围内，就会被吸附到相应的矢量点。具体的值就是在这里设置的。 snapTolerance, // 都是数值类型，maxPoints 表示绘制单个要素（面和线）最多的点数限制，默认没有限制；minPoints 表示绘制单个要素（面和线）需要的最少点数，面默认为 3，线默认为 2。 maxPoints & minPoints }); // 向 map 添加绘制元素的控件对象 map.addInteraction(draw); // 移除 map 绘制元素的控件对象 map.removeInteraction(draw); ol.interaction.Modify 修改几何元素 const modify = new Modify({ source, // 如果要修改已存在的 source 则配置 source features, // 如果要修改指定的 feature 则配置 feature }); ol.interaction.Select const select = new Select({ // 控制可以被选中的图层，它是一个数组 layers: [layer, layer], // 选取方式：点击、移入等 condition， // 设置是否多选 multi: Boolean }) 地图坐标偏差问题 在 react 项目中使用 ol 的时候，点击地图上的元素无效，但点击元素旁边的一小块区域时有效，感觉渲染的元素像发生了位移一样。最终解决办法需要给 map 容器定宽，否则在宽度自适应的情况下元素的渲染可能会发生偏差。 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/TypeScript.html":{"url":"notes/TypeScript.html","title":"TypeScript","keywords":"","body":"TypeScript TypeScript 是 JavaScript 的超集，它可以编译成纯 JavaScript 类型注解 类型注解是 TypeScript 里为函数或变量添加约束的方式，例： // 声明一个变量，且约束该变量的类型为布尔类型 let bool: boolean = false; // 为函数参数约束类型，这里约束为字符串类型 function greeter(person: string) { return \"Hello, \" + person; } Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/浏览器兼容.html":{"url":"notes/浏览器兼容.html","title":"浏览器兼容","keywords":"","body":"浏览器兼容 CSS 部分 HTML 部分 JavaScript 部分 BOM window 对象 全局作用域 IE 9 以下使用 delete 操作符删除 window 属性报错 // 此种方式定义的全局变量不可以通过 delete 操作符删除，因为通过 var 语句添加的 window 属性有一个名为 [[Configurable]]的特性，这个特性的值被设置为 false，因此不可以被 delete 删除 // 在 IE 9 以上 flag 为 false，IE 9 以下会报错 var age = 112 var flag = delete window.age console.log(flag); // 此种方式定义的全局变量可以通过 delete 操作符删除 // 在 IE 9 以上 flag 为 true，IE 9 以下会报错 window.age = 112 var flag = delete window.age console.log(flag) 窗口位置 获取窗口相对于屏幕左边和上边的位置，火狐不支持 screenLeft 和 screenTop，但支持 screenX 和 screenY，这两个属性其它浏览器也支持，但 opera 中的这两个属性与 screenLeft 和 screenTop 并不对应。兼容性写法： var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX; var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY; 在使用这些值的过程中，各浏览器表现的结果还有差别，因此，无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。 窗口大小 IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性。 无法跨浏览器确定浏览器窗口本身的大小，但却可以跨浏览器取得页面视口的大小。例： var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != \"number\") { // 通过检查 document.compatMode 来确定页面是否处于标准模式。 if (document.compatMode == \"CSS1Compat\") { pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; } else { // 混杂模式 pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; } } location 对象 location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性；换句话说， window.location 和 document.location 引用的是同一个对象。 navigator 对象 与其他 BOM 对象的情况一样，每个浏览器中的 navigator 对象也都有一套自己的属性。 客户端检测 能力检测 // 作者： Peter Michaux // 检测一个对象身上是否有该属性 function isHostMethod(object, property) { var t = typeof object[property]; return t == 'function' || (!!(t == 'object' && object[property])) || t == 'unknown'; } // 可以像下面这样使用这个函数： console.log(isHostMethod(window, \"sort\")); console.log(isHostMethod(window, \"location\")); 怪癖检测 与能力检测类似， 怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确 认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是 bug）。 这通常 需要运行一小段代码，以确定某一特性不能正常工作。 用户代理检测 以下是完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、 Windows 操作系统、移动设备 和游戏系统。 var client = function () { //呈现引擎 var engine = { ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //完整的版本号 ver: null }; //浏览器 var browser = { //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null }; //平台、设备和操作系统 var system = { win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, //游戏系统 wii: false, ps: false }; //检测呈现引擎和浏览器 var ua = navigator.userAgent; if (window.opera) { engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); } else if (/AppleWebKit\\/(\\S+)/.test(ua)) { engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); //确定是 Chrome 还是 Safari if (/Chrome\\/(\\S+)/.test(ua)) { browser.ver = RegExp[\"$1\"]; browser.chrome = parseFloat(browser.ver); } else if (/Version\\/(\\S+)/.test(ua)) { browser.ver = RegExp[\"$1\"]; browser.safari = parseFloat(browser.ver); } else { //近似地确定版本号 var safariVersion = 1; if (engine.webkit -1; system.ipod = ua.indexOf(\"iPod\") > -1; system.ipad = ua.indexOf(\"iPad\") > -1; system.nokiaN = ua.indexOf(\"NokiaN\") > -1; //windows mobile if (system.win == \"CE\") { system.winMobile = system.win; } else if (system.win == \"Ph\") { if (/Windows Phone OS (\\d+.\\d+)/.test(ua)) {; system.win = \"Phone\"; system.winMobile = parseFloat(RegExp[\"$1\"]); } } //检测 iOS 版本 if (system.mac && ua.indexOf(\"Mobile\") > -1) { if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua)) { system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\")); } else { system.ios = 2; //不能真正检测出来，所以只能猜测 } } //检测 Android 版本 if (/Android (\\d+\\.\\d+)/.test(ua)) { system.android = parseFloat(RegExp.$1); } //游戏系统 system.wii = ua.indexOf(\"Wii\") > -1; system.ps = /playstation/i.test(ua); //返回这些对象 return { engine: engine, browser: browser, system: system }; }(); DOM NodeList 转换为真数组 由于 IE 8 及更早版本将 NodeList 实现为一个 COM 对象，在通过 call() 方法传入 COM 对象会报错。 利用 try-catch 块来捕获错误，然后手动创建数组。这是另一种检测怪癖的 形式。 function convertToArray(nodes) { var array = null; try { array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器 } catch (ex) { array = new Array(); for (var i = 0, len = nodes.length; i 获取元素 document.getElementById Some text IE 7 及较低版本不区分 ID 的大小写，因此\"myDiv\"和\"mydiv\"会被当作相同的元素 ID，例： var div = document.getElementById(\"mydiv\"); //无效的 ID（在 IE7 及更早版本中可以） IE7 及较 低版本还为此方法添加了一个有意思的“怪癖”： name 特性与给定 ID 匹配的表单元素（input、 textarea、button 及 select）也会被该方法返回。 元素；而在其他所有浏览器中，都会返回对元素的引用。为了避免 IE 中存在的这个问 题，最好的办法是不让表单字段的 name 特性与其他元素的 ID 相同。 --> A div 遍历节点属性 // IE7 及更早的版本会返回 HTML 元素中所有可能的特性，包括没有指定的特性。换句话说，返回 100 多个特性的情况会很常见。 // 针对 IE7 及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。每个特性节点都有一个名为 specified 的属性，这个属性的值如果为 true，则意味着要么是在 HTML 中指定了相应特性，要么是通过 setAttribute()方法设置了该特性。在 IE 中，所有未设置过的特性的该属性值都为 false，而在其他浏览器中根本不会为这类特性生成对应的特性节点（因此，在这些浏览器中，任何特性节点的 specified 值始终为 true）。 function outputAttributes(element) { var pairs = new Array(), attrName, attrValue, i, len; for (i = 0, len = element.attributes.length; i 事件 跨浏览器的事件处理程序 兼容 addEventListener 和 IE 的事件处理程序 // 添加事件处理程序 function addHandler (element, type, handler) { if (element.addEventListener) { element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(\"on\" + type, handler); } else { element[\"on\" + type] = handler; } } //移除事件处理程序 function removeHandler (element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(\"on\" + type, handler); } else { element[\"on\" + type] = null; } } 跨浏览器的事件对象 兼容 IE，这些方法均接收一个 event 事件对象 // 得到事件对象 function getEvent(event) { return event ? event : window.event; } // 得到事件目标元素 function getTarget(event) { return event.target || event.srcElement; } // 阻止事件的默认行为 function preventDefault(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } } // 阻止事件冒泡 function stopPropagation(event) { if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } 事件类型 UI 事件 UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层 DOM 结构发生变化时触发。 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们， 因此本章不做介绍。 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/移动端一些概念和问题.html":{"url":"notes/移动端一些概念和问题.html","title":"移动端一些概念和问题","keywords":"","body":"移动端一些概念和问题 像素 物理像素 物理像素就是手机屏幕的分辨率，出厂的时候就被确定下来，不可修改 CSS 像素 css 像素是一个抽象的单位，主要使用在浏览器上。在一个标准的显示密度下，一个 CSS 像素对应一个设备像素 设备独立像素 设备独立像素是连结 css 像素和 物理像素的一个中介，它会由相关转换关系转换为物理像素 位图像素 位图像素是图片的最小数据单元，一个位图像素对应一个物理像素，图片才能得到完美清晰的展示 像素比 像素比 = 物理像素 / 设备独立像素 iphone6 的像素比 = 750 / 375 = 2 当写上 meta 标签后，width = device-width，使 css 像素与设备独立像素挂钩 即 css 像素等于设备独立像素 1 css 像素 = 4倍物理像素 可以通过 window.devicePixelRatio 来获取像素比 视口 布局视口 手机为了容纳为 pc 设计的网站，默认的布局视口远大于手机屏幕的宽度 布局视口的出现，在极大程度上帮助了桌面网站到移动设备上的转移。 可以通过document.documentElement.clientWidth来获取 视觉视口 视觉视口语设备屏幕一样宽，并且它的css像素的数量会随用户的缩放而改变 visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 理想视口 布局视口的默认宽度并不是一个理想的宽度，对于我们移动设备来说，最理想的情况是用户刚进入页面时不再需要 缩放。这就是为什么苹果和其他效仿苹果的浏览器厂商会引进理想视口！只有是专门为移动设备开发的网站，他才 有理想视口这一说。而且只有当你在页面中加入viewport的meta标签，理想视口才会生效。 完美视口 在引入理想视口时出现的一个问题，例：在 iphone6 下，将一个 div 的宽度设置为 375px ，占满了整个屏幕，但当该 div 元素的内容超出了盒子的宽度时，没有出现横线滚动条，反而是让视觉视口尽量的把所有超出的内容显示出来。因此，需要使用完美视口 em em 的具体大小跟 body 和 元素的 font-size 有关 如果设置 em 单位的元素没有设置 font-size ，则 1em 的大小 = body 的 font-size 大小 如果设置 em 单位的元素设置了 font-size，则 1em 的大小 = 该元素设置的 font-size 的大小 rem rem 的具体大小只跟 html 元素的 font-size 有关，跟元素设置的 font-size 无关 任何时候 1rem 的大小 = html 的 font-size 大小 适配 方案一： rem 适配 rem 适配原理：改变了一个元素在不同设备上占据的 CSS 像素的个数 rem 适配的优点：没有破坏完美视口 rem 适配的缺点：px 值到 rem 的转换太复杂 (function () { var styleNode = document.createElement('style'); var w = document.documentElement.clientWidth / 16 ; styleNode.innerHTML = 'html{ font-size: ' + w + 'px!important }' ; document.head.appendChild(styleNode); })() 方案二：viewport 适配 viewport适配的原理：viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像 素和物理像素的比例是不一样的，等比的 优点:所量即所得，直接写设计稿给定的 px 尺寸，缺点:没有使用完美视口 (function(){ // targetW 代表设计稿的尺寸 var targetW = 750; var scale = document.documentElement.clientWidth/targetW; var meta = document.querySelector(\"meta[name='viewport']\"); meta.content=\"initial-scale=\"+scale+\",minimum-scale=\"+scale+\",maximum-scale=\"+scale+\",user-scalable=no\"; })() 方案三：百分比布局 首选百分比布局方案，但当页面元素足够多的时候，百分比布局会显得比较麻烦 1 物理像素 方案一：淘宝团队解决方案 (function(){ // 获取像素比，若不支持 devicePixelRatio 则默认为 1 var dpr = window.devicePixelRatio || 1; var styleNode = document.createElement(\"style\"); var w = document.documentElement.clientWidth*dpr/16; styleNode.innerHTML=\"html{font-size:\"+w+\"px!important}\"; document.head.appendChild(styleNode); var scale = 1/dpr; var meta = document.querySelector(\"meta[name='viewport']\"); meta.content=\"width=device-width,initial-scale=\"+scale+\",minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"; })() 方案二：主流 .border{ width: 100%; height:1px ; margin-top: 50px; background: black; } /* 当像素比为 2 时，高度缩小一倍 */ @media only screen and (-webkit-device-pixel-ratio:2 ) { .border{ transform: scaleY(.5); } } /* 当像素比为 3 时，高度缩小至三分之一 */ @media only screen and (-webkit-device-pixel-ratio:3 ) { .border{ transform: scaleY(.333333333333333333); } IE6 中最小高度问题 如果一个元素的高度小于 19px 那么在 IE6 中都会显示为 19px ，因为 IE6 中的最小高度为 19px 解决方案，给这个高度小与 19px 的元素的父元素加上 font-size: 0 这个属性 问题：虽然解决了最小高度 19px 的问题，但 IE6 最低只能兼容到 2px，也就是说 1px 高度的元素在 IE6 下最少也是 2px 移动端优化 移动端能给高度尽量给高度，减少重构重排 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "},"notes/面试题.html":{"url":"notes/面试题.html","title":"面试题","keywords":"","body":"面试题 HTML 部分 HTML 语义化 见名知意，根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 优点： 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于 SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 遵循 W3C 标准，可以减少差异化。 b 标签和 strong 标签的区别 两者虽然在网页中显示效果一样，但实际目的不同。 b 这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求； strong 这个标签意思是加强，表示该文本比较重要，提醒读者／终端注意。 CSS 部分 任意元素垂直水平居中 基础结构 #app { height: 500px; border: 10px solid #000; } .box { width: 200px; height: 200px; background-color: red; } 方式一：兼容性好。缺点：必须知道元素的宽高 #app { position: relative; } .box { position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px; } 方式二：使用的是 css3 里的样式。缺点：兼容性不好，只支持IE9+的浏览器 #app { position: relative; } .box { position: absolute; left: 50%; top: 50%; transform:translate(-50%,-50%); } 方式三：兼容性较好。缺点：不支持 IE7 以下的浏览器 #app { position: relative; } .box { position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } 方式四：flex #app { display: flex; justify-content: center; align-items: center; } 方式五：flex 结合 margin #app { display: flex; } .box { margin: auto; } 方式六：css3 中的 display: box; #app { display: -webkit-box; -webkit-box-pack: center; -webkit-box-align: center; } 方式七：table 布局 #app { display: table-cell; text-align: center; vertical-align: middle; } .box { display: inline-block; } 移动端 0.5px 实现 .border{ width: 100%; height:1px ; } /* 当像素比为 2 时，高度缩小一倍 */ @media only screen and (-webkit-device-pixel-ratio:2 ) { .border{ transform: scaleY(.5); } } /* 当像素比为 3 时，高度缩小至三分之一 */ @media only screen and (-webkit-device-pixel-ratio:3 ) { .border{ transform: scaleY(.333333333333333333); } 清除浮动的方法 /*清除浮动代码*/ .clearfloat::after{ display:block; clear:both; content:\"\"; visibility:hidden; height:0 } .clearfloat{ zoom:1 /* zoom(IE专有属性)可解决ie6,ie7浮动问题 */ } 在结尾处添加空 div 标签 clear:both 父级 div 定义 height 父级 div 定义 overflow:hidden; 结尾处加 br 标签clear:both JavaScript 部分 Object.keys() 和 for in 的区别 Object.keys（obj）返回的是对象本身的属性和方法的键组成的数组 for in 遍历的是对象本身及其原型上的属性伪数组转真数组 方式一：Array.prototype.slice.call() 方式二：ES6 中 Array.from() 方式三：ES6 中 var args = [...arguments]; 注意：ES6 的方法需要被转换的数据部署了 Iterator 接口 typeof 和 instanceof 的区别 typeof：检测基本数据类型和检测是否是函数很有用。但检测引用类型的值时用处不大。 instanceof： 可以检测一个对象是什么类型的对象，可以检测一个变量是否某个对象的实例。 alert(person instanceof Object); // 变量 person 是 Object 吗？ alert(colors instanceof Array); // 变量 colors 是 Array 吗？ alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？ 箭头函数和普通函数的区别 箭头函数没有绑定this指针，普通函数的this指向调用函数的对象（匿名函数的this都指向全局window对象）; 箭头函数没有构造器 如何深浅拷贝一个数组 浅复制：直接使用等号赋值，例：var arr2 = arr1 深复制： 使用 slice 方法截取数组，从 0 下标开始截取至末尾 使用 map 方法 使用 concat 方法 使用 for in 先将数组转字符串，在转数组 数组去重 遍历该数组，利用 indexOf 方法查找是否存在，不存在则添加到一个新数组内 使用空对象，将数组元素作为对象key值，出现次数作为value值，循环数组 普通的for循环，循环之前排序，会高效一点点 使用ES6的Set类型，[...new Set([1,2,3,2,3,1,4,5])]; //[1,2,3,4,5]; 作用域，执行上下文栈，变量对象 作用域： 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 可执行代码： 这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做\"执行上下文(execution context)\"。 执行上下文栈（管理执行上下文）： 我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 每个执行上下文，都有三个重要属性：变量对象(Variable object，VO)，作用域链(Scope chain)，this 变量对象： 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 执行上下文的执行过程： 进入执行上下文，此时的变量对象包括： 函数的所有形参 (如果是函数上下文) 函数声明 变量声明 代码执行 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 跨域 为什么会跨域？ ​ 因为浏览器的同源策略，它是一个安全机制。 解决方法： JSONP，但 JSONP 只能发送 get 请求，因为本质上 script 加载资源就是 get 服务端设置响应头，Access-Control-Allow-Origin 等参数 代理，配置 Nginx 性能优化方案 减少 HTTP 请求，例如使用精灵图，图片懒加载。 尽量少操作 DOM 资源压缩与合并 浏览器缓存 使用 CDN 使用事件代理 少用全局变量 路由懒加载 深浅拷贝 浅拷贝 function simpleCopy(obj) { var o = {} Object.keys(obj).forEach(item => { o[item] = obj[item] }) return o } 深拷贝 function deepCopy(current, target) { for (var key in current) { // 存当前 key 的 value 值 var value = current[key] // 如果这个值是数组类型 if (value instanceof Array) { // 让目标对象的当前 Key 为一个空数组 target[key] = [] // 递归进行拷贝 arguments.callee(value, target[key]) } else if (value instanceof Object) { // 让目标对象的当前 key 为一个空对象 target[key] = {} // 递归进行拷贝 arguments.callee(value, target[key]) } else { target[key] = value } } } 模拟实现 new 的模拟实现 参考地址：https://github.com/mqyqingfeng/Blog/issues/13 new 的时候发生了什么 创建一个新对象 将新对象的__proto__属性设置为构造函数的constructor的prototype 使用新对象调用 apply 函数，函数中的 this 被指向新实例对象 将初始化完毕的新对象地址返回 // Otaku 御宅族，简称宅 function Otaku(name, age) { this.name = name; this.age = age; this.habit = 'Games'; } // 因为缺乏锻炼的缘故，身体强度让人担忧 Otaku.prototype.strength = 60; Otaku.prototype.sayYourName = function () { console.log('I am ' + this.name); } function objectFactory() { // 创建一个新对象 var obj = new Object(), // 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 Constructor = [].shift.call(arguments); // 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 obj.__proto__ = Constructor.prototype; // 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性，用 ret 接受函数调用的一个返回值 var ret = Constructor.apply(obj, arguments); // 对返回值进行判断是否为对象 return typeof ret === 'object' ? ret : obj; } var instance = objectFactory(Otaku, 'yzn', 23) call 的模拟实现 call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 ES3 实现方式 Function.prototype.call = function (context) { context = context || window; // 该 this 表示的是 call 函数的调用者，也就是那个想被调用的函数，例：fn.call()，this 就是这个 fn context.fn = this; var args = []; for(var i = 1, len = arguments.length; i ES6 实现方式 Function.prototype.call = function(context, ...args) { context = context || window; let fn = Symbol() context[fn] = this; var result = context[fn](...args) Reflect.deleteProperty(context, fn) return result; } apply 的模拟实现 apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 Function.prototype.apply = function (context, arr) { context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i bind 的模拟实现 bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。 参考地址：https://github.com/mqyqingfeng/Blog/issues/12 Function.prototype.bind2 = function (context) { if (typeof this !== \"function\") { throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); } var self = this; // 取出 bind 时传入的参数并转换为一个数组，例：fn.bind(this, 1, 2)，args = [1, 2] var args = Array.prototype.slice.call(arguments, 1); // 利用一个空函数进行中转 var fNOP = function () {}; var fBound = function () { // 取出 bind 返回的函数调用时传入的参数，例，fBound(3, 4)，bindArgs = [3, 4] var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; } Vue 部分 Vue 组件通信相关方法 方式一：vue 父子组件通信可以用 Vue.$emit 自定义事件来解决。 // 子组件 methods: { editAddress () { this.$emit('edit-address', false) } } 方式二：利用 props 通信 // 子组件 export default { props: { addressitems: Object } } 方式三：非父子组件通信 // 新建一个 bus.js 文件，在需要通信的组件都引入该 bus.js 文件 import Vue from 'vue' export default new Vue() // 传递数据的组件中 Bus.$emit('on', 'hello') // 接收数据的组件中 Bus.$on('on', (msg) => { this.message = msg // hello }) 方式四：使用 vm 实例属性，$attr 和 $listeners 方式五：使用 provide 和 inject，主要为高阶插件/组件库提供用例。 方式六：$parent 和 $children 方式七：Vuex Vue 生命周期都做了什么事情 首先创建了一个空的 Vue 实例对象，然后初始化一些生命周期函数和默认事件 在 beforeCreate 执行的时候 data 和 methods 中的数据还没有初始化完成 在 beforeCreate 执行完成之后，data 和 methods 中的数据都已经被初始化完成了 这时 created 钩子中可以访问到 data 和 methods 中的数据 在 created 和 beforeMount 之间 Vue 开始编译好模板，放在内存中 接着 beforeMount 钩子执行，但此时内存中的模板还未挂在到页面中 在 beforeMount 钩子执行完后，才把内存中的模板挂载到页面中去 然后 mounted 钩子执行，此时 Vue 实例初始化完毕，并在该阶段可以操作 DOM 了 在 mounted 和 beforeDestory 之间是 beforeUpdate 和 update 钩子 接着 beforeDestory 钩子执行，此时 Vue 实例准备销毁，但仍然可以访问 data 和 methods 等数据 当执行 destoryed 钩子时，所有的指令方法等都不可用了，Vue 实例被销毁。 new Vue 发生了什么 Vue 初始化只要就是干了这几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等。 初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。 浏览器部分 防止浏览器缓存的方法 方式一：meta方法 有时候谷歌等浏览器不支持 方式二：请求头添加 If-Modified-Since 和 Cache-Control $.ajax({ url: 'www.xxxxxx.com', dataType: 'json', beforeSend: function (xmlHttp) { xmlHttp.setRequestHeader(\"If-Modified-Since\", \"0\"); xmlHttp.setRequestHeader(\"Cache-Control\", \"no-cache\"); }, }); 方式三：在 url 后加上随机数或时间戳 方式四：服务端设置 header(\"Cache-Control: no-cache, must-revalidate\"); HTTP 部分 HTTP 和 HTTPS 有何区别？如何灵活使用 http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份 GET 请求和 POST 请求的区别 get 请求可以被缓存，post 不可以 编码类型不同，post 请求可以为 form-data get 请求有长度限制，post 没有 get 请求的安全性较差，因为所发送的参数是 url 的一部分 get 请求的数据所有人都可见，post 请求的数据不会显示在 url 中 get 请求可以收藏为书签，post 不可以 Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Axios 的特点 从浏览器中创建 XMLHttpRequests 从 nodejs 创建 http 请求 支持 Promise API 有 interceptor 拦截器 自动转换 JSON 数据 客户端支持防御 XSRF，安全性高 Copyright © yaozhongnan All Right Reserved all right reserved，powered by Gitbook该文章修订时间： 2019-08-19 09:37:12 "}}