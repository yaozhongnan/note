# 第四章 - 变量、作用域和内存问题

JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。

由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。

尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性。

但 JavaScript 变量实际的复杂程度还远不止如此。



## 基本类型和引用类型

ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。

基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 

在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。

基本数据类型（五种）是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。

与其他语言不同，JavaScript 不允许直接访问内存中的位置。

也就是说不能直接操作对象的内存空间。

在操作对象时，实际上是在操作对象的引用而不是实际的对象。

为此，引用类型的值是按引用（不严密，见 68 页注解）访问的。 

在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript 放弃了这一传统。



## 传递参数

**结论：ECMAScript 中所有函数的参数都是按值传递的。**

有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数）。

在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

下面证明一下为什么所有函数的参数都是按值传递的，看第一个例子：

```js
function addTen(num) { 
    num += 10; 
    return num; 
} 
var count = 20; 
var result = addTen(count); 
alert(count);    //20，没有变化 
alert(result);   //30

/*
	这里向 addTen 函数传递了一个基本类型值 20，20 会被赋值给变量参数 num，num 和 count 互不认识，假如 num 是按引用传递的话，那么外部的 count 应该也变为 30 才对。
*/
```

```js
function setName(obj) { 
    obj.name = "Nicholas"; 
} 
 
var person = new Object(); 
setName(person); 
alert(person.name);    //"Nicholas" 

/*
	这里传入了一个对象给 setName 函数，obj 会与 person 指向相同的一个内存空间，因此 obj.name 修改了 name 属性就造成了 person.name 的变化
*/
```

```js
function setName(obj) { 
    obj.name = "Nicholas"; 
    obj = new Object(); 
    obj.name = "Greg"; 
} 
 
var person = new Object(); 
setName(person); 
alert(person.name);    //"Nicholas"

/*
	该例子与上一个例子不同的地方是 obj 改变了自己的指向，但在未改变指向前修改了原指向的 name 属性，因此外部的 person.name 值是 Nicholas。obj 改变了指向后操作的是另一块内存空间，因此不影响 person
*/
```

> 个人理解：向参数传递对象这样的复杂类型时之所以也是按值传递，是因为传递的是对象的地址值。



## 检测类型

+ typeof 非常适合检测基本数据类型，因为检测对象和 null 时总是返回 object。
+ instanceof 非常适合检测对象的类型，可以检测变量是不是某个对象的实例。

> 注意：使用 typeof 检测函数时因浏览器差异可能会返回 function 或 object



## 执行上下文（执行环境）

执行上下文也可以叫执行环境，执行上下文决定了能否访问其他数据。js 引擎在分析和执行代码时，并非是逐行解析，而是逐段的解析。

JavaScript 的可执行代码：全局代码、函数代码、eval 代码，也是逐段解析的代码。

当执行一个函数的时候，会进行一个准备工作，这里的“准备工作”，就是创建"执行上下文"。

而所有的执行上下文都由一个执行上下文栈管理着。

每个执行上下文都由三个重要部分组成：变量对象、作用域链、this。

执行上下文初始化时就会创建这个三个属性。

+ 变量对象中保存着执行环境中定义的所有变量和函数。
+ 作用域链是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的顶端始终是当前执行的代码所
  在环境的变量对象。底端始终是全局环境的变量对象。标识符的解析就是按照作用域链逐层查找的。
+ this



## 延长作用域链

+ 延长作用域链的做法是在作用域链的顶端临时增加一个变量对象，该变量对象会在代码执行完后移除。
+ with 与 try catch 语句的 catch 块都会延长作用域链。



## 垃圾收集

JavaScript 具有自动垃圾收集机制。

+ 标记清除（标记变量状态）
+ 引用计数（计算变量的引用次数，0 次引用则视为无效变量销毁。问题：循环引用）



## 小结

+ 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 
+ 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 
+ 引用类型的值是对象，保存在堆内存中； 
+ 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； 
+ 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
+ 确定一个值是哪种基本类型可以使用 typeof，而确定一个值是哪种引用类型可使用 instanceof 。 
+ 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。 
+ “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记
  后再回收其内存。 
+ 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaS
  引擎目前都不再使用这种算法；但在IE 中访问非原生JavaScript 对象（如DOM 元素）时，
  算法仍然可能会导致问题。 
+ 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 
+ 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效
  收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 