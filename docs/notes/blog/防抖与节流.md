# 防抖与节流

在前端开发中会遇到一些频繁的事件触发，比如：

+ window 的 resize、scroll
+ mousedown、mousemove
+ touchmove

在这些事件中如果加入的是一些复杂的逻辑或异步请求的代码的时候，就会出现卡顿的现象。因为事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。

因此为了解决这个问题出现了两种解决方案：防抖和节流。

防抖与节流都是为了减少事件的执行次数。



## 防抖

防抖的原理是在事件频繁触发时并不立即执行事件处理函数，而是等到事件触发结束，且触发结束后的 n 秒时间内都没有再次触发事件的话，那么这时执行一次事件处理函数。在执行了一次事件处理函数之后，如果又触发了新的事件，同样等到触发结束后的 n 秒后才执行。

防抖的原理非常像进出电梯，电梯总是在进出人(监听事件)之后的 5 秒关门(执行方法)，如果 5 秒钟之内又有人进出，则重新开始计时，直到最后一个进出电梯的事件发生 5 秒钟之后执行关门。

```js
// func 参数：事件处理函数
// wait 参数：等待时间
function debounce(func, wait) {
    var timeout;
    return function() {
        clearTimeout(timeout);
        var ctx = this;
        var args = arguments;
        timeout = setTimeout(function() {
            func.apply(ctx, args);
        }, wait);
    };
}
```

使用：

```js
document.body.onmousemove = debounce(function (e) {
    console.log('触发了');
    console.log(this);	// body
    console.log(e);		// MouseEvent
}, 1000);
```

